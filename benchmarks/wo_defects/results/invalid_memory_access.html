<!DOCTYPE html>
<html>
<head>
<style>
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0000FF } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
.result { color: #F03434 }
.count { text-align: right }
.bug_counts { font-family: monospace; }
table { border-collapse: collapse; border-spacing: 0px; margin-bottom: 10px; }
table, th, td { padding: 5px; border: 1px solid black; }
</style>
</head>
<body>
<div class="bug_counts">
<table style="display: inline-table;">
<tr><th colspan="2">flawfinder</th></tr><tr><td>(buffer) strcpy</td><td class="count">6</td></tr><tr><td>(buffer) memcpy</td><td class="count">1</td></tr><tr><td>(buffer) char</td><td class="count">2</td></tr><tr><td>(buffer) strlen</td><td class="count">1</td></tr></table>
<table style="display: inline-table;">
<tr><th colspan="2">cppcheck</th></tr><tr><td>memleak</td><td class="count">2</td></tr></table>
<table style="display: inline-table;">
<tr><th colspan="2">scan-build</th></tr><tr><td>core.NullDereference</td><td class="count">3</td></tr></table>
<table style="display: inline-table;">
<tr><th colspan="2">infer</th></tr><tr><td>Dead Store</td><td class="count">12</td></tr><tr><td>Null Dereference</td><td class="count">4</td></tr></table>
</div>
<div class="highlight"><pre>
  1 <span class="cm">/********Software Analysis - FY2013*************/</span>
  2 <span class="cm">/*</span>
  3 <span class="cm">* File Name: invalid_memory_access.c</span>
  4 <span class="cm">* Defect Classification</span>
  5 <span class="cm">* ---------------------</span>
  6 <span class="cm">* Defect Type: Resource management defects</span>
  7 <span class="cm">* Defect Sub-type: Invalid memory access to already freed area</span>
  8 <span class="cm">* Description: Defect Free Code to identify false positives during invalid memory access</span>
  9 <span class="cm">*/</span>
 10 
 11 <span class="cm">/*</span>
 12 <span class="cm"> * invalid_memory_access.c</span>
 13 <span class="cm"> *</span>
 14 <span class="cm"> *  Created on: Sep 20, 2013</span>
 15 <span class="cm"> *      Author: hemalatha</span>
 16 <span class="cm"> */</span>
 17 
 18 <span class="cp">#include</span> <span class="cpf">&quot;HeaderFile.h&quot;</span><span class="cp"></span>
 19 
 20 <span class="kt">char</span> <span class="o">**</span> <span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">;</span>
 21 <span class="kt">char</span> <span class="o">*</span><span class="n">invalid_memory_access_017_doubleptr_gbl</span><span class="p">;</span>
 22 
 23 <span class="k">static</span> <span class="kt">int</span> <span class="n">staticflag1</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
 24 <span class="cm">/*</span>
 25 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
 26 <span class="cm">* Complexity : Memory is allocated and accessed after free -  when using pointer to int and conditional operator</span>
 27 <span class="cm">*/</span>
 28 <span class="kt">void</span> <span class="nf">invalid_memory_access_001</span> <span class="p">()</span>
 29 <span class="p">{</span>
 30 	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">a</span><span class="p">;</span>
 31 	<span class="kt">int</span> <span class="n">flag</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
 32 
 33     <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span><span class="o">?</span> <span class="p">(</span><span class="n">ptr</span><span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span> <span class="o">:</span> <span class="p">(</span> <span class="n">ptr</span><span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>
 34 
 35     <span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
 36     <span class="p">{</span>
 37     	<span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span><span class="o">?</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">100</span><span class="p">);</span>
 38         <span class="k">if</span><span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
 39         <span class="p">{</span>
 40         	<span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
 41         	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="n">a</span><span class="p">);</span>
 42        <span class="p">}</span>
 43         <span class="k">if</span><span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
 44         <span class="p">{</span>
 45         	<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
 46     	    <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &ptr is never used.</span>
 47          <span class="p">}</span>
 48      <span class="p">}</span>
 49 <span class="p">}</span>
 50 
 51 <span class="cm">/*</span>
 52 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
 53 <span class="cm">*  Complexity : Memory is allocated and accessed after free -</span>
 54 <span class="cm">*  when using pointer to double,conditional statement if ~else using static variable of function scope</span>
 55 <span class="cm">*/</span>
 56 
 57 <span class="kt">void</span> <span class="nf">invalid_memory_access_002</span> <span class="p">()</span>
 58 <span class="p">{</span>
 59 	<span class="kt">double</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">;</span>
 60 	<span class="k">static</span> <span class="kt">int</span> <span class="n">staticflag</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
 61     <span class="k">if</span> <span class="p">(</span><span class="n">staticflag</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
 62     	  	<span class="p">(</span><span class="n">ptr</span><span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)));</span>
 63     <span class="k">else</span>
 64     	  	<span class="p">(</span><span class="n">dptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)));</span>
 65 
 66     <span class="k">if</span>  <span class="p">(</span><span class="n">staticflag</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
 67     		<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">10.5</span><span class="p">);</span>
 68     <span class="k">else</span>
 69     	    <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">dptr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">5.5</span><span class="p">)</span> <span class="p">;</span>
<span class="result">    > scan-build: (Logic error core.NullDereference) Dereference of null pointer</span>
 70 
 71     <span class="k">if</span><span class="p">(</span><span class="n">staticflag</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
 72     	<span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
 73     <span class="k">else</span>
 74     	<span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">dptr</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
 75 
 76 	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf&quot;</span><span class="p">,</span><span class="n">a</span><span class="p">);</span>
 77 
 78     <span class="k">if</span><span class="p">(</span><span class="n">staticflag</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
 79     <span class="p">{</span>
 80     	<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
 81     	<span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &ptr is never used.</span>
 82     <span class="p">}</span>
 83     <span class="k">else</span>
 84     <span class="p">{</span>
 85     	<span class="n">free</span><span class="p">(</span><span class="n">dptr</span><span class="p">);</span>
 86     	<span class="n">dptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > cppcheck: (error memleak) Memory leak: dptr</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &dptr is never used.</span>
 87     <span class="p">}</span>
 88 <span class="p">}</span>
<span class="result">    > cppcheck: (error memleak) Memory leak: dptr</span>
 89 
 90 <span class="cm">/*</span>
 91 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
 92 <span class="cm">* Complexity: Memory is allocated and accessed after free -</span>
 93 <span class="cm">* When using a pointer to char in an infinite while loop and Strcpy</span>
 94 <span class="cm">*/</span>
 95 <span class="kt">void</span> <span class="nf">invalid_memory_access_003</span> <span class="p">()</span>
 96 <span class="p">{</span>
 97 	<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
 98 	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 99 	<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
100 	<span class="p">{</span>
101 		<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="mi">25</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
102 		<span class="k">if</span><span class="p">(</span><span class="n">buf</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
103 		<span class="p">{</span>
104 			<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="s">&quot;This is String&quot;</span><span class="p">);</span>
<span class="result">    > flawfinder: ([2] (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused). Risk is low because the source is a constant string.</span>
105 	        <span class="n">c</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
106 	        <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
107     	    <span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &buf is never used.</span>
108 		<span class="p">}</span>
109 	    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
110 	    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">10</span><span class="p">)</span>
111 	    	<span class="k">break</span><span class="p">;</span>
112 	<span class="p">}</span>
113         <span class="n">psink</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
114 <span class="p">}</span>
115 
116 <span class="cm">/*</span>
117 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
118 <span class="cm">* Complexity: Memory is allocated and accessed after free -</span>
119 <span class="cm">* When using a pointer to char and initialize memory block with memset and if condition using static variable of file scope</span>
120 <span class="cm">*/</span>
121 <span class="kt">void</span> <span class="nf">invalid_memory_access_004</span> <span class="p">()</span>
122 <span class="p">{</span>
123     <span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &buf is never used.</span>
124     <span class="k">if</span><span class="p">(</span><span class="n">staticflag1</span><span class="p">)</span>
125     <span class="p">{</span>
126         <span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
127         <span class="k">if</span><span class="p">(</span><span class="n">buf</span> <span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
128         <span class="p">{</span>
129         	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
130             <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
131             <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
132             <span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &buf is never used.</span>
133         <span class="p">}</span>
134     <span class="p">}</span>
135 <span class="p">}</span>
136 
137 <span class="cm">/*</span>
138 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
139 <span class="cm">* Complexity: When using a pointer to int in a recursive function</span>
140 <span class="cm">*/</span>
141 <span class="kt">int</span> <span class="nf">invalid_memory_access_005</span> <span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
142 <span class="p">{</span>
143 	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">;</span>
144 
145 	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
146 	<span class="p">{</span>
147     	<span class="c1">//count = *ptr;</span>
148 		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
149 	<span class="p">}</span>
150     <span class="k">else</span>
151     <span class="p">{</span>
152     	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">calloc</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
153     	<span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
154     	<span class="p">{</span>
155     		<span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">count</span><span class="p">;</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
156     	    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
157     	    <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &ptr is never used.</span>
158     	<span class="p">}</span>
159     	<span class="k">return</span> <span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="n">invalid_memory_access_005</span><span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
160     <span class="p">}</span>
161 <span class="p">}</span>
162 
163 <span class="cm">/*</span>
164 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
165 <span class="cm">* Complexity: When using double pointers to the type float</span>
166 <span class="cm">*/</span>
167 <span class="kt">void</span> <span class="nf">invalid_memory_access_006</span> <span class="p">()</span>
168 <span class="p">{</span>
169 	<span class="kt">float</span> <span class="o">*</span><span class="n">buf1</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
170 	<span class="kt">float</span> <span class="o">*</span><span class="n">buf2</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
171 	<span class="kt">float</span> <span class="o">*</span><span class="n">buf3</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
172 	<span class="kt">float</span> <span class="o">*</span><span class="n">buf4</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
173 	<span class="kt">float</span> <span class="o">*</span><span class="n">buf5</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
174 	<span class="kt">float</span> <span class="o">**</span><span class="n">pbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">buf1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf5</span><span class="p">};</span>
175 	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
176 	<span class="k">if</span><span class="p">(</span><span class="n">buf2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
177 	<span class="p">{</span>
178 	<span class="n">buf2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
179 	<span class="p">}</span>
180 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
181 	<span class="p">{</span>
182 		<span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">pbuf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="mf">5.0</span><span class="p">;</span>
<span class="result">    > scan-build: (Logic error core.NullDereference) Dereference of null pointer</span>
183 	<span class="p">}</span>
184 	<span class="k">if</span><span class="p">(</span><span class="n">buf2</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
185 	<span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">pbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span><span class="n">buf2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
186 	<span class="k">if</span><span class="p">(</span><span class="n">buf1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
187 	<span class="n">free</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span>
188 	<span class="k">if</span><span class="p">(</span><span class="n">buf2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
189 	<span class="n">free</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span>
190 	<span class="k">if</span><span class="p">(</span><span class="n">buf3</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
191 	<span class="n">free</span><span class="p">(</span><span class="n">buf3</span><span class="p">);</span>
192 	<span class="k">if</span><span class="p">(</span><span class="n">buf4</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
193 	<span class="n">free</span><span class="p">(</span><span class="n">buf4</span><span class="p">);</span>
194 	<span class="k">if</span><span class="p">(</span><span class="n">buf5</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
195 	<span class="n">free</span><span class="p">(</span><span class="n">buf5</span><span class="p">);</span>
196 <span class="p">}</span>
197 
198 <span class="cm">/*</span>
199 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
200 <span class="cm">* Complexity: When using double pointers to the type char 2D array of size [5][15] ,strcpy</span>
201 <span class="cm">*/</span>
202 <span class="kt">void</span> <span class="nf">invalid_memory_access_007</span> <span class="p">()</span>
203 <span class="p">{</span>
204 	<span class="kt">char</span> <span class="o">**</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">));</span>
205 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
206 
207 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
208 		<span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">15</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `ptr` last assigned on line 204 could be null and is dereferenced at line 208, column 3.</span>
209 
210 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
211 	<span class="p">{</span>
212 		<span class="n">strcpy</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="n">i</span><span class="p">),</span><span class="s">&quot;String&quot;</span><span class="p">);</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > flawfinder: ([2] (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused). Risk is low because the source is a constant string.</span>
213 	    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
214 	    <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
215 	<span class="p">}</span>
216 	<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
217 	<span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &ptr is never used.</span>
218 	<span class="cm">/* strcpy(*(ptr+2),&quot;String&quot;); */</span>
219 <span class="p">}</span>
220 
221 <span class="cm">/*</span>
222 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
223 <span class="cm">* Complexity: When using 1 single char pointer  memcpy function</span>
224 <span class="cm">*/</span>
225 <span class="kt">void</span> <span class="nf">invalid_memory_access_008</span> <span class="p">()</span>
226 <span class="p">{</span>
227 	<span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
228 	<span class="kt">char</span><span class="o">*</span> <span class="n">buf1</span><span class="o">=</span> <span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
229 	<span class="k">if</span><span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
230 	<span class="p">{</span>
231 		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">buf1</span><span class="p">,</span><span class="mi">11</span><span class="p">);</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > flawfinder: ([2] (buffer) memcpy) Does not check for buffer overflows when copying to destination (CWE-120).  Make sure destination can always hold the source data.</span>
232 	    <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
233 	    <span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &buf is never used.</span>
234 	<span class="p">}</span>
235 <span class="p">}</span>
236 
237 <span class="cm">/*</span>
238 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
239 <span class="cm">* Complexity: When using a Union with structure members - Aliasing</span>
240 <span class="cm">*/</span>
241 <span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
242 	<span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
243 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
244 <span class="p">}</span> <span class="n">invalid_memory_access_009_s_001</span><span class="p">;</span>
245 
246 <span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
247 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
248 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
249 <span class="p">}</span> <span class="n">invalid_memory_access_009_s_002</span><span class="p">;</span>
250 
251 <span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
252 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
253 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
254 <span class="p">}</span> <span class="n">invalid_memory_access_009_s_003</span><span class="p">;</span>
255 
256 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
257 	<span class="n">invalid_memory_access_009_s_001</span> <span class="o">*</span><span class="n">s1</span><span class="p">;</span>
258 	<span class="n">invalid_memory_access_009_s_002</span> <span class="n">s2</span><span class="p">;</span>
259 	<span class="n">invalid_memory_access_009_s_003</span> <span class="n">s3</span><span class="p">;</span>
260 <span class="p">}</span> <span class="n">invalid_memory_access_009_uni_001</span><span class="p">;</span>
261 
262 <span class="kt">void</span> <span class="nf">invalid_memory_access_009</span> <span class="p">()</span>
263 <span class="p">{</span>
264 	<span class="n">invalid_memory_access_009_uni_001</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">invalid_memory_access_009_uni_001</span> <span class="o">*</span> <span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span> <span class="n">invalid_memory_access_009_uni_001</span> <span class="p">));</span>
265 	<span class="n">invalid_memory_access_009_uni_001</span> <span class="o">*</span><span class="n">p</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &p is never used.</span>
266 
267     <span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
268     <span class="p">{</span>
269 	<span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span> <span class="o">=</span> <span class="p">(</span><span class="n">invalid_memory_access_009_s_001</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">invalid_memory_access_009_s_001</span><span class="p">));</span>
270 	<span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
271 	<span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
272 
273 	<span class="n">p</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
274 	<span class="n">p</span><span class="o">-&gt;</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > scan-build: (Logic error core.NullDereference) Access to field 'a' results in a dereference of a null pointer (loaded from field 's1')</span>
275 
276 	<span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">);</span>
277 	<span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span><span class="p">);</span>
278 	<span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
279     <span class="p">}</span>
280 <span class="p">}</span>
281 
282 <span class="cm">/*</span>
283 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
284 <span class="cm">* Complexity Memory allocated in a function and Memory used in another function</span>
285 <span class="cm">*/</span>
286 <span class="kt">void</span> <span class="nf">invalid_memory_access_func_010</span> <span class="p">(</span><span class="kt">int</span> <span class="n">len</span> <span class="p">,</span><span class="kt">int</span> <span class="o">**</span><span class="n">Ptr</span><span class="p">)</span>
287 <span class="p">{</span>
288 	<span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">len</span><span class="p">);</span>
289 	<span class="o">*</span><span class="n">Ptr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
290 <span class="p">}</span>
291 
292 <span class="kt">void</span> <span class="nf">invalid_memory_access_010</span> <span class="p">()</span>
293 <span class="p">{</span>
294 	<span class="kt">int</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
295 	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">,</span><span class="n">i</span><span class="p">;</span>
296 	<span class="n">invalid_memory_access_func_010</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ptr1</span><span class="p">);</span>
297 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
298 	<span class="p">{</span>
299 		<span class="o">*</span><span class="p">(</span><span class="n">ptr1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
300 	<span class="p">}</span>
301 	<span class="n">free</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>
302 <span class="p">}</span>
303 
304 <span class="cm">/*</span>
305 <span class="cm">* Types of defects: Invalid memory access</span>
306 <span class="cm">* Complexity: 1-dimensional array</span>
307 <span class="cm">*/</span>
308 <span class="kt">void</span> <span class="nf">invalid_memory_access_011</span> <span class="p">()</span>
309 <span class="p">{</span>
310 	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
311 	<span class="kt">int</span> <span class="n">index</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
312 	<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
313 	<span class="p">{</span>
314 		<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
315 		<span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
316 		<span class="p">{</span>
317 		   <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">)</span>
318 		   <span class="p">{</span>
319 			   <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
320 	           <span class="n">i</span><span class="o">++</span><span class="p">;</span>
321 	       <span class="p">}</span>
322 	       <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
323 		<span class="p">}</span>
324 	    <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">)</span>
325 	    <span class="k">break</span><span class="p">;</span>
326 	<span class="p">}</span>
327 	<span class="cm">/* *(ptr+i) = i; */</span>
328 <span class="p">}</span>
329 
330 <span class="cm">/*</span>
331 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
332 <span class="cm">* Complexity: When using switch case</span>
333 <span class="cm">*/</span>
334 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
335 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
336 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
337 	<span class="kt">int</span> <span class="n">uninit</span><span class="p">;</span>
338 <span class="p">}</span> <span class="n">invalid_memory_access_012_s_001</span><span class="p">;</span>
339 
340 <span class="kt">int</span> <span class="nf">invalid_memory_access_012_func_001</span> <span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
341 <span class="p">{</span>
342 
343 	<span class="n">invalid_memory_access_012_s_001</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
344 	<span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">invalid_memory_access_012_s_001</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">invalid_memory_access_012_s_001</span><span class="p">));</span>
345 	<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
346 	<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
347 	<span class="p">{</span>
348 		<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
349 		<span class="p">{</span>
350 			<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
351 			<span class="p">{</span>
352 			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
353 			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
354 			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">uninit</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
355 			     <span class="n">i</span><span class="o">=</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
356      			 <span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
357 			<span class="p">}</span>
358 			<span class="k">break</span><span class="p">;</span>
359 		<span class="p">}</span>
360 		<span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
361 		<span class="p">{</span>
362 			<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
363 			<span class="p">{</span>
364 			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
365 			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
366 			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">uninit</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
367 			     <span class="n">i</span><span class="o">=</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
368      			 <span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
369 			<span class="p">}</span>
370 			<span class="k">break</span><span class="p">;</span>
371 		<span class="p">}</span>
372 		<span class="k">default</span><span class="o">:</span>
373 		<span class="p">{</span>
374 			<span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
375 			<span class="k">break</span><span class="p">;</span>
376 		<span class="p">}</span>
377 	<span class="p">}</span>
378 	<span class="cm">/*return s-&gt;a;*/</span>
379 	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
380 <span class="p">}</span>
381 
382 <span class="kt">void</span> <span class="nf">invalid_memory_access_012</span> <span class="p">()</span>
383 <span class="p">{</span>
384 	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
385 	<span class="n">ret</span> <span class="o">=</span> <span class="n">invalid_memory_access_012_func_001</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
386 	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="n">ret</span><span class="p">);</span>
387 <span class="p">}</span>
388 
389 <span class="cm">/*</span>
390 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
391 <span class="cm">* Complexity: Double pointer - double	Alias for 1 weight	Address	Constant	Write</span>
392 <span class="cm">*/</span>
393 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
394 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
395 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
396 	<span class="kt">int</span> <span class="n">uninit</span><span class="p">;</span>
397 <span class="p">}</span> <span class="n">invalid_memory_access_013_s_001</span><span class="p">;</span>
398 <span class="n">invalid_memory_access_013_s_001</span> <span class="o">*</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="p">;</span>
399 
400 <span class="kt">void</span> <span class="nf">invalid_memory_access_013_func_001</span> <span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
401 <span class="p">{</span>
402 	<span class="k">if</span><span class="p">(</span><span class="n">flag</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
403 	<span class="n">invalid_memory_access_013_s_001_s_gbl</span> <span class="o">=</span> <span class="p">(</span><span class="n">invalid_memory_access_013_s_001</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">invalid_memory_access_013_s_001</span><span class="p">));</span>
404 <span class="p">}</span>
405 
406 <span class="kt">int</span> <span class="nf">invalid_memory_access_013_func_002</span> <span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
407 <span class="p">{</span>
408 	<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
409 	<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
410 	<span class="p">{</span>
411 		<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
412 		<span class="p">{</span>
413 			<span class="k">if</span> <span class="p">(</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
414 			<span class="p">{</span>
415 				<span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
416 				<span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
417 				<span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">uninit</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
418 				<span class="n">i</span><span class="o">=</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
419 				<span class="n">free</span><span class="p">(</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="p">);</span>
420 			<span class="p">}</span>
421 			<span class="k">break</span><span class="p">;</span>
422 		<span class="p">}</span>
423 		<span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
424 		<span class="p">{</span>
425 			<span class="k">if</span> <span class="p">(</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
426 			<span class="p">{</span>
427 				<span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
428 				<span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
429 				<span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">uninit</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
430 				<span class="n">i</span><span class="o">=</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
431 				<span class="n">free</span><span class="p">(</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="p">);</span>
432 			<span class="p">}</span>
433 			<span class="k">break</span><span class="p">;</span>
434 		<span class="p">}</span>
435 		<span class="k">default</span><span class="o">:</span>
436 		<span class="p">{</span>
437 			<span class="k">break</span><span class="p">;</span>
438 		<span class="p">}</span>
439 	<span class="p">}</span>
440 	<span class="cm">/*return invalid_memory_access_013_s_001_s_gbl-&gt;a;*/</span>
441 	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
442 <span class="p">}</span>
443 
444 <span class="kt">void</span> <span class="nf">invalid_memory_access_013_func_003</span> <span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
445 <span class="p">{</span>
446 	<span class="n">invalid_memory_access_013_s_001</span> <span class="n">s</span><span class="p">;</span>
447 	<span class="k">if</span><span class="p">(</span><span class="n">flag</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
448 	<span class="p">{</span>
449 		<span class="k">if</span> <span class="p">(</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
450 		<span class="p">{</span>
451 			<span class="n">s</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
452 			<span class="n">s</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span>
453 			<span class="n">s</span><span class="p">.</span><span class="n">uninit</span> <span class="o">=</span> <span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">uninit</span><span class="p">;</span>
454 		<span class="p">}</span>
455 	<span class="p">}</span>
456 <span class="p">}</span>
457 
458 <span class="kt">void</span> <span class="nf">invalid_memory_access_013</span> <span class="p">()</span>
459 <span class="p">{</span>
460 	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
461 	<span class="n">invalid_memory_access_013_func_001</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
462 	<span class="n">invalid_memory_access_013_func_003</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
463 	<span class="n">ret</span> <span class="o">=</span> <span class="n">invalid_memory_access_013_func_002</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
464 	
465 	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="n">ret</span><span class="p">);</span>
466 <span class="p">}</span>
467 
468 <span class="cm">/*</span>
469 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
470 <span class="cm">* Complexity: When using a pointer to int and  goto</span>
471 <span class="cm">*/</span>
472 <span class="kt">int</span> <span class="nf">invalid_memory_access_014</span> <span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
473 <span class="p">{</span>
474 	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">;</span>
475 	<span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
476 	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span><span class="p">);</span>
477 	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
478 	<span class="p">{</span>
479 		<span class="k">goto</span> <span class="n">my_label</span><span class="p">;</span>
480 	<span class="p">}</span>
481 	<span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
482     <span class="n">ret</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
483 	<span class="k">goto</span> <span class="n">my_label2</span><span class="p">;</span>
484 <span class="nl">my_label</span><span class="p">:</span>
485 	    <span class="p">{</span>
486             <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
487             <span class="p">{</span>
488             	<span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
489             		<span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
490             <span class="p">}</span>
491 	    <span class="p">}</span>
492 <span class="nl">my_label2</span><span class="p">:</span>
493     <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
494 	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
495 <span class="p">}</span>
496 
497 <span class="cm">/*</span>
498 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
499 <span class="cm">* Complexity: Use a block of memory returned from a function after it has been freed</span>
500 <span class="cm">*/</span>
501 
502 <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">invalid_memory_access_015_func_001</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str1</span><span class="p">)</span>
503 <span class="p">{</span>
504     <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &i is never used.</span>
505     <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
506     <span class="kt">char</span> <span class="o">*</span> <span class="n">str_rev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &str_rev is never used.</span>
507     <span class="k">if</span> <span class="p">(</span><span class="n">str1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
508     <span class="p">{</span>
509         <span class="n">i</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str1</span><span class="p">);</span>
<span class="result">    > flawfinder: ([1] (buffer) strlen) Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).</span>
510         <span class="n">str_rev</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
511         <span class="k">if</span> <span class="p">(</span><span class="n">str_rev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
512         <span class="p">{</span>
513         	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
514             <span class="p">{</span>
515                 <span class="n">str_rev</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
516             <span class="p">}</span>
517             <span class="n">str_rev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
518         <span class="p">}</span>
519         <span class="cm">/*free(str_rev) ;</span>
520 <span class="cm">        str_rev = NULL;*/</span>
521         <span class="k">return</span> <span class="n">str_rev</span><span class="p">;</span>
522     <span class="p">}</span>
523     <span class="k">else</span>
524     <span class="p">{</span>
525         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
526     <span class="p">}</span>
527 <span class="p">}</span>
528 <span class="kt">void</span> <span class="nf">invalid_memory_access_015</span> <span class="p">()</span>
529 <span class="p">{</span>
530     <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
531     <span class="kt">char</span> <span class="n">buf</span><span class="p">[][</span><span class="mi">25</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;This is a String&quot;</span><span class="p">,</span>
532     		     <span class="s">&quot;Second String&quot;</span><span class="p">};</span>
533     <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
534     <span class="p">{</span>
535         <span class="p">{</span>
536             <span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">;</span>
537             <span class="n">str</span> <span class="o">=</span> <span class="n">invalid_memory_access_015_func_001</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
538             <span class="n">psink</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
539         <span class="p">}</span>
540     <span class="p">}</span>
541 <span class="p">}</span>
542 
543 <span class="cm">/*</span>
544 <span class="cm">* Types of defects: Uninitialized pointer</span>
545 <span class="cm">* Complexity: global char double pointer  variable initialized in another function</span>
546 <span class="cm"> */</span>
547 <span class="kt">int</span> <span class="nf">invalid_memory_access_016_func_001</span><span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
548 <span class="p">{</span>
549    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
550    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
551 	   <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
552    <span class="k">else</span>
553 	   <span class="n">ret</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
554    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
555 <span class="p">}</span>
556 
557 <span class="kt">void</span> <span class="nf">invalid_memory_access_016_func_002</span><span class="p">()</span>
558 <span class="p">{</span>
559 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
560 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_016_func_001</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
561 	<span class="p">{</span>
562 		<span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">));</span>
563     	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
564 	    <span class="p">{</span>
565     		<span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `invalid_memory_access_016_doubleptr_gbl` last assigned on line 562 could be null and is dereferenced at line 565, column 7.</span>
566     		   <span class="n">strcpy</span><span class="p">(</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="s">&quot;STRING00&quot;</span><span class="p">);</span>
<span class="result">    > flawfinder: ([2] (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused). Risk is low because the source is a constant string.</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `*invalid_memory_access_016_doubleptr_gbl[i]` last assigned on line 565 could be null and is dereferenced by call to `strcpy()` at line 566, column 10.</span>
567 	    <span class="p">}</span>
568 	<span class="p">}</span>
569 <span class="p">}</span>
570 
571 <span class="kt">void</span> <span class="nf">invalid_memory_access_016_func_003</span><span class="p">()</span>
572 <span class="p">{</span>
573 	<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
<span class="result">    > flawfinder: ([2] (buffer) char) Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).  Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.</span>
574 	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;invalid gbl= %s </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
575 	<span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/* No ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > flawfinder: ([4] (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused).</span>
576 	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;invalid str= %s </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
577 <span class="p">}</span>
578 
579 <span class="kt">void</span> <span class="nf">invalid_memory_access_016</span><span class="p">()</span>
580 <span class="p">{</span>
581 	<span class="kt">int</span> <span class="n">flag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">;</span>
582 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_016_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
583 	<span class="p">{</span>
584 		<span class="n">invalid_memory_access_016_func_002</span><span class="p">();</span>
585 	<span class="p">}</span>
586 	
587 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_016_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
588 	<span class="p">{</span>
589 		<span class="n">invalid_memory_access_016_func_003</span><span class="p">();</span>
590 	<span class="p">}</span>
591 	
592 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
593 	<span class="p">{</span>
594 		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
595 		<span class="p">{</span>
596 			<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
597 			<span class="n">free</span> <span class="p">(</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
598 	    <span class="p">}</span>
599 	    <span class="n">free</span><span class="p">(</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">);</span>
600 	<span class="p">}</span>
601 
602 <span class="p">}</span>
603 <span class="cm">/*</span>
604 <span class="cm">* Types of defects: Uninitialized pointer</span>
605 <span class="cm">* Complexity: global char pointer  variable initialized in another function , freed in another function based in while loop</span>
606 <span class="cm"> */</span>
607 <span class="kt">int</span> <span class="nf">invalid_memory_access_017_func_001</span><span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
608 <span class="p">{</span>
609    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
610    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
611 	   <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
612    <span class="k">else</span>
613 	   <span class="n">ret</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
614    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
615 <span class="p">}</span>
616 
617 <span class="kt">void</span> <span class="nf">invalid_memory_access_017_func_002</span><span class="p">()</span>
618 <span class="p">{</span>
619 	<span class="n">invalid_memory_access_017_doubleptr_gbl</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
620 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_017_doubleptr_gbl</span> <span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
621 	<span class="n">strcpy</span><span class="p">(</span><span class="n">invalid_memory_access_017_doubleptr_gbl</span><span class="p">,</span><span class="s">&quot;TEST&quot;</span><span class="p">);</span>
<span class="result">    > flawfinder: ([2] (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused). Risk is low because the source is a constant string.</span>
622 <span class="p">}</span>
623 
624 <span class="kt">void</span> <span class="nf">invalid_memory_access_017_func_003</span><span class="p">()</span>
625 <span class="p">{</span>
626 	<span class="n">free</span><span class="p">(</span><span class="n">invalid_memory_access_017_doubleptr_gbl</span><span class="p">);</span>
627 <span class="p">}</span>
628 
629 <span class="kt">void</span> <span class="nf">invalid_memory_access_017_func_004</span><span class="p">()</span>
630 <span class="p">{</span>
631 	<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
<span class="result">    > flawfinder: ([2] (buffer) char) Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).  Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.</span>
632 	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;invalid gbl= %s </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">invalid_memory_access_017_doubleptr_gbl</span><span class="p">);</span>
633 	<span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">invalid_memory_access_017_doubleptr_gbl</span><span class="p">);</span> <span class="cm">/*Tool should not detect this line as error*/</span> <span class="cm">/*No ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > flawfinder: ([4] (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused).</span>
634 	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;invalid str= %s </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
635 <span class="p">}</span>
636 
637 
638 <span class="kt">void</span> <span class="nf">invalid_memory_access_017</span><span class="p">()</span>
639 <span class="p">{</span>
640 	<span class="kt">int</span> <span class="n">flag</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
641 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_017_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
642 	<span class="p">{</span>
643 		<span class="p">;</span>
644 	<span class="p">}</span>
645 	<span class="k">else</span>
646 	<span class="p">{</span>
647 		<span class="n">invalid_memory_access_017_func_002</span><span class="p">();</span>
648 	<span class="p">}</span>
649 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_017_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
650 	<span class="p">{</span>
651 		<span class="p">;</span>
652 	<span class="p">}</span>
653 	<span class="k">else</span>
654 	<span class="p">{</span>
655 		<span class="n">invalid_memory_access_017_func_004</span><span class="p">();</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `invalid_memory_access_017_doubleptr_gbl` last assigned on line 647 could be null and is dereferenced by call to `invalid_memory_access_017_func_004()` at line 655, column 3.</span>
656 	<span class="p">}</span>
657 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_017_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
658 	<span class="p">{</span>
659 		<span class="p">;</span>
660 	<span class="p">}</span>
661 	<span class="k">else</span>
662 	<span class="p">{</span>
663 		<span class="n">invalid_memory_access_017_func_003</span><span class="p">();</span>
664 	<span class="p">}</span>
665 
666 
667 <span class="p">}</span>
668 
669 <span class="cm">/*</span>
670 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
671 <span class="cm">* Complexity:Invalid memory access main function</span>
672 <span class="cm">*/</span>
673 <span class="k">extern</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">vflag</span><span class="p">;</span>
674 <span class="kt">void</span> <span class="nf">invalid_memory_access_main</span> <span class="p">()</span>
675 <span class="p">{</span>
676 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
677 	<span class="p">{</span>
678 		<span class="n">invalid_memory_access_001</span><span class="p">();</span>
679 	<span class="p">}</span>
680 
681 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
682 	<span class="p">{</span>
683 		<span class="n">invalid_memory_access_002</span><span class="p">();</span>
684 	<span class="p">}</span>
685 
686 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
687 	<span class="p">{</span>
688 		<span class="n">invalid_memory_access_003</span><span class="p">();</span>
689 	<span class="p">}</span>
690 
691 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
692 	<span class="p">{</span>
693 		<span class="n">invalid_memory_access_004</span><span class="p">();</span>
694 	<span class="p">}</span>
695 
696 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">5</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
697 	<span class="p">{</span>
698 		<span class="n">invalid_memory_access_005</span> <span class="p">(</span><span class="mi">5</span><span class="p">);</span>
699 	<span class="p">}</span>
700 
701 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
702 	<span class="p">{</span>
703 		<span class="n">invalid_memory_access_006</span><span class="p">();</span>
704 	<span class="p">}</span>
705 
706 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">7</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
707 	<span class="p">{</span>
708 		<span class="n">invalid_memory_access_007</span><span class="p">();</span>
709 	<span class="p">}</span>
710 
711 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
712 	<span class="p">{</span>
713 		<span class="n">invalid_memory_access_008</span><span class="p">();</span>
714 	<span class="p">}</span>
715 
716 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">9</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
717 	<span class="p">{</span>
718 		<span class="n">invalid_memory_access_009</span><span class="p">();</span>
719 	<span class="p">}</span>
720 
721 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
722 	<span class="p">{</span>
723 		<span class="n">invalid_memory_access_010</span><span class="p">();</span>
724 	<span class="p">}</span>
725 
726 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">11</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
727 	<span class="p">{</span>
728 		<span class="n">invalid_memory_access_011</span><span class="p">();</span>
729 	<span class="p">}</span>
730 
731 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">12</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
732 	<span class="p">{</span>
733 		<span class="n">invalid_memory_access_012</span><span class="p">();</span>
734 	<span class="p">}</span>
735 
736 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">13</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
737 	<span class="p">{</span>
738 		<span class="n">invalid_memory_access_013</span><span class="p">();</span>
739 	<span class="p">}</span>
740 
741 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">14</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
742 	<span class="p">{</span>
743 		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
744 		<span class="n">i</span> <span class="o">=</span> <span class="n">invalid_memory_access_014</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
745                 <span class="n">sink</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
746 	<span class="p">}</span>
747 
748 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">15</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
749 	<span class="p">{</span>
750 		<span class="n">invalid_memory_access_015</span><span class="p">();</span>
751 	<span class="p">}</span>
752 
753 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">16</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
754 	<span class="p">{</span>
755 		<span class="n">invalid_memory_access_016</span><span class="p">();</span>
756 	<span class="p">}</span>
757 
758 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">17</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
759 	<span class="p">{</span>
760 		<span class="n">invalid_memory_access_017</span><span class="p">();</span>
761 	<span class="p">}</span>
762 <span class="p">}</span>
763 
</pre></div>
</body>
</html>

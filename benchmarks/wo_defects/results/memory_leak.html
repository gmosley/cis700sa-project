<!DOCTYPE html>
<html>
<head>
<style>
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0000FF } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
.result { color: #F03434 }
.count { text-align: right }
.bug_counts { font-family: monospace; }
table { border-collapse: collapse; border-spacing: 0px; margin-bottom: 10px; }
table, th, td { padding: 5px; border: 1px solid black; }
</style>
</head>
<body>
<div class="bug_counts">
<table style="display: inline-table;">
<tr><th colspan="2">flawfinder</th></tr><tr><td>(buffer) strcpy</td><td class="count">6</td></tr><tr><td>(buffer) strlen</td><td class="count">3</td></tr></table>
<table style="display: inline-table;">
<tr><th colspan="2">scan-build</th></tr><tr><td>core.NullDereference</td><td class="count">1</td></tr><tr><td>deadcode.DeadStores</td><td class="count">1</td></tr><tr><td>unix.cstring.NullArg</td><td class="count">1</td></tr></table>
<table style="display: inline-table;">
<tr><th colspan="2">infer</th></tr><tr><td>Null Dereference</td><td class="count">5</td></tr><tr><td>Dead Store</td><td class="count">12</td></tr></table>
</div>
<div class="highlight"><pre>
  1 <span class="cm">/********Software Analysis - FY2013*************/</span>
  2 <span class="cm">/*</span>
  3 <span class="cm">* File Name: memory_leak.c</span>
  4 <span class="cm">* Defect Classification</span>
  5 <span class="cm">* ---------------------</span>
  6 <span class="cm">* Defect Type: Resource management defects</span>
  7 <span class="cm">* Defect Sub-type: Memory leakage</span>
  8 <span class="cm">* Description: Defect Free Code to identify false positives in memory leak conditions</span>
  9 <span class="cm">*/</span>
 10 
 11 <span class="cp">#include</span> <span class="cpf">&quot;HeaderFile.h&quot;</span><span class="cp"></span>
 12 
 13 <span class="kt">int</span> <span class="nf">rand</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 14 
 15 <span class="cm">/*</span>
 16 <span class="cm">* Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
 17 <span class="cm">* Complexity: When using a pointer to char in an infinite for loop</span>
 18 <span class="cm">*/</span>
 19 <span class="kt">void</span> <span class="nf">memory_leak_001</span> <span class="p">()</span>
 20 <span class="p">{</span>
 21 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
 22 	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
 23 	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
 24 	<span class="p">{</span>
 25 		<span class="n">buf</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
 26 		<span class="k">if</span><span class="p">(</span><span class="n">buf</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
 27 		<span class="p">{</span>
 28 			<span class="o">*</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
 29 		    <span class="n">free</span> <span class="p">(</span><span class="n">buf</span><span class="p">);</span>
 30 		<span class="p">}</span>
 31 		<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">10</span><span class="p">)</span>
 32 		<span class="k">break</span><span class="p">;</span>
 33 	<span class="p">}</span>
 34 <span class="p">}</span>
 35 
 36 <span class="cm">/*</span>
 37 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
 38 <span class="cm"> * When using double pointers to the type INT</span>
 39 <span class="cm"> */</span>
 40 
 41 <span class="kt">void</span> <span class="nf">memory_leak_002</span> <span class="p">()</span>
 42 <span class="p">{</span>
 43 	<span class="kt">int</span> <span class="o">**</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">**</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">));</span>
 44 	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
 45 
 46 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
 47 		<span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `ptr` last assigned on line 43 could be null and is dereferenced at line 47, column 3.</span>
 48 
 49 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
 50 	<span class="p">{</span>
 51 		<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
 52 		<span class="p">{</span>
 53 			<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
 54 		<span class="p">}</span>
 55 	    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
 56 	<span class="p">}</span>
 57 	<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
 58 <span class="p">}</span>
 59 
 60 <span class="cm">/*</span>
 61 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
 62 <span class="cm"> *  Memory allocated in a function and Memory used in another function</span>
 63 <span class="cm"> */</span>
 64 <span class="kt">void</span> <span class="nf">memory_leak_003_func_001</span> <span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">stringPtr</span><span class="p">)</span>
 65 <span class="p">{</span>
 66 	<span class="kt">char</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
 67 	<span class="o">*</span><span class="n">stringPtr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
 68 <span class="p">}</span>
 69 
 70 <span class="kt">void</span> <span class="nf">memory_leak_003</span> <span class="p">()</span>
 71 <span class="p">{</span>
 72 	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
 73 	<span class="kt">char</span> <span class="o">*</span><span class="n">str1</span><span class="p">;</span>
 74 	<span class="n">memory_leak_003_func_001</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">),</span><span class="o">&amp;</span><span class="n">str1</span><span class="p">);</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
<span class="result">    > flawfinder: ([1] (buffer) strlen) Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).</span>
 75 	<span class="n">strcpy</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span><span class="n">str</span><span class="p">);</span>
<span class="result">    > flawfinder: ([4] (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused).</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `str1` last assigned on line 74 could be null and is dereferenced by call to `strcpy()` at line 75, column 2.</span>
 76 	<span class="n">free</span><span class="p">(</span><span class="n">str1</span><span class="p">);</span>
 77 <span class="p">}</span>
 78 
 79 <span class="cm">/*</span>
 80 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
 81 <span class="cm"> * When using pointers to the structure with an string as a member of the structure</span>
 82 <span class="cm"> */</span>
 83 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
 84 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
 85 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
 86 	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
 87 <span class="p">}</span> <span class="n">memory_leak_004_s_001</span><span class="p">;</span>
 88 
 89 <span class="kt">void</span> <span class="nf">memory_leak_004</span> <span class="p">()</span>
 90 <span class="p">{</span>
 91 	<span class="n">memory_leak_004_s_001</span><span class="o">*</span> <span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="n">memory_leak_004_s_001</span><span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">memory_leak_004_s_001</span><span class="p">))</span> <span class="p">;</span>
 92 	<span class="kt">char</span> <span class="o">*</span><span class="n">s1</span><span class="o">=</span><span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
 93 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
 94 	<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
 95 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span> <span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
 96 	<span class="p">{</span>
 97 		<span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">25</span><span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
 98 	<span class="p">}</span>
 99 	<span class="n">strcpy</span><span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span><span class="n">s1</span><span class="p">);</span>
<span class="result">    > flawfinder: ([4] (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused).</span>
<span class="result">    > scan-build: (Logic error core.NullDereference) Access to field 'buf' results in a dereference of a null pointer</span>
100 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span> <span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
101 		<span class="n">free</span><span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
102 	<span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
103 <span class="p">}</span>
104 
105 <span class="cm">/*</span>
106 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
107 <span class="cm"> *  When using pointer to float Memory is allocated and freed in conditional statement(if)</span>
108 <span class="cm"> */</span>
109 <span class="kt">void</span> <span class="nf">memory_leak_005</span><span class="p">()</span>
110 <span class="p">{</span>
111 	<span class="kt">float</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
112 	<span class="kt">int</span> <span class="n">flag</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
113 
114 	<span class="k">if</span><span class="p">(</span><span class="n">flag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
115 	<span class="p">{</span>
116 		<span class="n">ptr</span><span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
117 		<span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
118 		<span class="p">{</span>
119 			<span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">10.5</span><span class="p">;</span>
120 			<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
121 		<span class="p">}</span>
122 	<span class="p">}</span>
123 <span class="p">}</span>
124 
125 <span class="cm">/*</span>
126 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
127 <span class="cm"> *  When using pointer to double Memory is allocated and freed based on return value of function</span>
128 <span class="cm"> */</span>
129 <span class="kt">int</span> <span class="nf">memory_leak_006_func_001</span><span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
130 <span class="p">{</span>
131    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
132    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
133 	   <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
134    <span class="k">else</span>
135 	   <span class="n">ret</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
136    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
137 <span class="p">}</span>
138 
139 <span class="kt">void</span> <span class="nf">memory_leak_006</span><span class="p">()</span>
140 <span class="p">{</span>
141 	<span class="kt">double</span> <span class="o">*</span><span class="n">dptr</span><span class="p">;</span>
142 	<span class="kt">int</span> <span class="n">flag</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
143 
144 	<span class="k">if</span><span class="p">(</span><span class="n">memory_leak_006_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
145 	<span class="p">{</span>
146 		<span class="n">dptr</span><span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
147 		<span class="k">if</span><span class="p">(</span><span class="n">dptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
148 		<span class="p">{</span>
149            <span class="o">*</span><span class="p">(</span><span class="n">dptr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">10.50000</span><span class="p">;</span>
150        	   <span class="n">free</span><span class="p">(</span><span class="n">dptr</span><span class="p">);</span>
151 		<span class="p">}</span>
152 	<span class="p">}</span>
153 <span class="p">}</span>
154 
155 <span class="cm">/*</span>
156 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
157 <span class="cm"> *  When using Switch case statements and void pointer</span>
158 <span class="cm"> */</span>
159 <span class="kt">void</span> <span class="o">*</span><span class="n">vptr</span><span class="p">;</span>
160 <span class="kt">int</span> <span class="nf">memory_leak_007_func_001</span> <span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
161 <span class="p">{</span>
162 	<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
163 	<span class="p">{</span>
164 		<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
165 		<span class="p">{</span>
166 			<span class="n">vptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
167 			<span class="k">if</span><span class="p">(</span><span class="n">vptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
168 			<span class="p">{</span>
169 			   <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">vptr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
170 			<span class="p">}</span>
171 			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
172 		<span class="p">}</span>
173 		<span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
174 		<span class="p">{</span>
175 			<span class="n">vptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
176 			<span class="k">if</span><span class="p">(</span><span class="n">vptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
177 			<span class="p">{</span>
178 			   <span class="o">*</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">vptr</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
179 			<span class="p">}</span>
180 			<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
181 		<span class="p">}</span>
182 		<span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
183 		<span class="p">{</span>
184 			<span class="n">vptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
185 			<span class="k">if</span><span class="p">(</span><span class="n">vptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
186 			<span class="p">{</span>
187 			   <span class="o">*</span><span class="p">((</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">vptr</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mf">5.5</span><span class="p">;</span>
188 			<span class="p">}</span>
189 			<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
190 		<span class="p">}</span>
191 		<span class="k">default</span><span class="o">:</span>
192 			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
193 	<span class="p">}</span>
194 <span class="p">}</span>
195 
196 <span class="kt">void</span> <span class="nf">memory_leak_007</span> <span class="p">()</span>
197 <span class="p">{</span>
198 	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
199 	<span class="n">ret</span> <span class="o">=</span> <span class="n">memory_leak_007_func_001</span> <span class="p">(</span><span class="n">rand</span><span class="p">());</span>
200 	<span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="p">)</span>
201 		<span class="k">if</span><span class="p">(</span><span class="n">vptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
202 		<span class="p">{</span>
203 		   <span class="n">free</span><span class="p">(</span><span class="n">vptr</span><span class="p">);</span>
204 		<span class="p">}</span>
205 <span class="p">}</span>
206 
207 <span class="cm">/*</span>
208 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
209 <span class="cm">*  When using 1 single pointer alias</span>
210 <span class="cm">*/</span>
211 <span class="kt">void</span> <span class="nf">memory_leak_008</span> <span class="p">()</span>
212 <span class="p">{</span>
213 	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
214 	<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &p is never used.</span>
215 	<span class="k">if</span><span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
216 	<span class="p">{</span>
217 	   <span class="n">p</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
218 	   <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
219 	   <span class="n">free</span> <span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
220 	   <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &ptr is never used.</span>
221 	<span class="p">}</span>
222 <span class="p">}</span>
223 
224 <span class="cm">/*</span>
225 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
226 <span class="cm">*  When using 1 single pointer alias  - pointing to different type</span>
227 <span class="cm">*/</span>
228 <span class="kt">void</span> <span class="nf">memory_leak_009</span> <span class="p">()</span>
229 <span class="p">{</span>
230 	<span class="kt">float</span> <span class="o">*</span><span class="n">ptr</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
231 	<span class="kt">float</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &p is never used.</span>
232 	<span class="k">if</span><span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
233 	<span class="p">{</span>
234 	   <span class="n">p</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
235 	   <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">;</span>
236 	   <span class="n">free</span> <span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
237 	   <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &ptr is never used.</span>
238 	<span class="p">}</span>
239 <span class="p">}</span>
240 
241 <span class="cm">/*</span>
242 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
243 <span class="cm">*  When using 2 single pointer alias</span>
244 <span class="cm">*/</span>
245 <span class="kt">void</span> <span class="nf">memory_leak_0010</span> <span class="p">()</span>
246 <span class="p">{</span>
247 	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
248 	<span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &p1 is never used.</span>
249 	<span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &p2 is never used.</span>
250 	<span class="k">if</span><span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
251 	<span class="p">{</span>
252 	   <span class="n">p1</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
253 	   <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
254 	   <span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
255 	   <span class="n">free</span> <span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
256 	<span class="p">}</span>
257 <span class="p">}</span>
258 
259 <span class="cm">/*</span>
260 <span class="cm">* Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
261 <span class="cm">*  When using alias(union) - a union containing two methods of accessing the same data (within the same function) alias</span>
262 <span class="cm">*/</span>
263 <span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
264     <span class="kt">char</span> <span class="o">*</span> <span class="n">u1</span><span class="p">;</span>
265     <span class="kt">char</span> <span class="o">*</span> <span class="n">u2</span><span class="p">;</span>
266 <span class="p">}</span> <span class="n">memory_leak_0011_uni_001</span><span class="p">;</span>
267 
268 
269 <span class="kt">void</span> <span class="nf">memory_leak_0011</span><span class="p">()</span>
270 <span class="p">{</span>
271     <span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &buf is never used.</span>
272     <span class="n">memory_leak_0011_uni_001</span> <span class="n">un</span><span class="p">;</span>
273     <span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
274 	<span class="k">if</span><span class="p">(</span><span class="n">buf</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
275 	<span class="p">{</span>
276           <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;This Is A String&quot;</span><span class="p">);</span>
<span class="result">    > flawfinder: ([2] (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused). Risk is low because the source is a constant string.</span>
277           <span class="n">un</span><span class="p">.</span><span class="n">u1</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
278           <span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">un</span><span class="p">.</span><span class="n">u1</span><span class="p">;</span>
279           <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span>
280             <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
281           <span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &buf is never used.</span>
282         <span class="p">}</span>
283 <span class="p">}</span>
284 
285 <span class="cm">/*</span>
286 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
287 <span class="cm"> * Complexity: Union of pointer	Constant	 expressions	Write</span>
288 <span class="cm"> */</span>
289 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
290 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
291 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
292 <span class="p">}</span> <span class="n">memory_leak_0012_s_001</span><span class="p">;</span>
293 
294 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
295 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
296 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
297 <span class="p">}</span> <span class="n">memory_leak_0012_s_002</span><span class="p">;</span>
298 
299 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
300 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
301 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
302 <span class="p">}</span> <span class="n">memory_leak_0012_s_003</span><span class="p">;</span>
303 
304 <span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
305 	<span class="n">memory_leak_0012_s_001</span> <span class="n">s1</span><span class="p">;</span>
306 	<span class="n">memory_leak_0012_s_002</span> <span class="n">s2</span><span class="p">;</span>
307 	<span class="n">memory_leak_0012_s_003</span> <span class="n">s3</span><span class="p">;</span>
308 <span class="p">}</span> <span class="n">memory_leak_0012_uni_001</span><span class="p">;</span>
309 
310 <span class="kt">void</span> <span class="nf">memory_leak_0012</span> <span class="p">()</span>
311 <span class="p">{</span>
312 	<span class="n">memory_leak_0012_uni_001</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">memory_leak_0012_uni_001</span> <span class="o">*</span> <span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span> <span class="n">memory_leak_0012_uni_001</span> <span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
313 	<span class="n">memory_leak_0012_uni_001</span> <span class="o">*</span><span class="n">p</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &p is never used.</span>
314 	<span class="n">p</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
315     <span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
316     <span class="p">{</span>
317     	<span class="n">p</span><span class="o">-&gt;</span><span class="n">s1</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
318 	    <span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
319     <span class="p">}</span>
320 <span class="p">}</span>
321 
322 <span class="cm">/*</span>
323 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
324 <span class="cm"> * Complexity: Union of pointer	Constant	 expressions	Write</span>
325 <span class="cm"> */</span>
326 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
327 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
328 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
329 <span class="p">}</span> <span class="n">memory_leak_0013_s_001</span><span class="p">;</span>
330 
331 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
332 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
333 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
334 <span class="p">}</span> <span class="n">memory_leak_0013_s_002</span><span class="p">;</span>
335 
336 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
337 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
338 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
339 <span class="p">}</span> <span class="n">memory_leak_0013_s_003</span><span class="p">;</span>
340 
341 <span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
342 	<span class="n">memory_leak_0013_s_001</span> <span class="o">*</span><span class="n">s1</span><span class="p">;</span>
343 	<span class="n">memory_leak_0013_s_002</span> <span class="o">*</span><span class="n">s2</span><span class="p">;</span>
344 	<span class="n">memory_leak_0013_s_003</span> <span class="o">*</span><span class="n">s3</span><span class="p">;</span>
345 <span class="p">}</span> <span class="n">memory_leak_0013_uni_001</span><span class="p">;</span>
346 
347 <span class="kt">void</span> <span class="nf">memory_leak_0013</span> <span class="p">()</span>
348 <span class="p">{</span>
349 	<span class="n">memory_leak_0013_uni_001</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">memory_leak_0013_uni_001</span> <span class="o">*</span> <span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span> <span class="n">memory_leak_0013_uni_001</span> <span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
350 	<span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
351 	<span class="p">{</span>
352 		<span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span> <span class="o">=</span> <span class="p">(</span><span class="n">memory_leak_0013_s_001</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">memory_leak_0013_s_001</span><span class="p">));</span>
353 	<span class="p">}</span>
354 	<span class="n">memory_leak_0013_uni_001</span> <span class="o">*</span><span class="n">p</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &p is never used.</span>
355 	
356 	<span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
357 	<span class="p">{</span>
358 		<span class="n">p</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
359 	    <span class="n">p</span><span class="o">-&gt;</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
360 	    <span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span><span class="p">);</span>
361 	    <span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
362 	    <span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
363 	<span class="p">}</span>
364 <span class="p">}</span>
365 
366 <span class="cm">/*</span>
367 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
368 <span class="cm">*  Using two double pointers to the same value within the same function</span>
369 <span class="cm">*/</span>
370 <span class="kt">void</span> <span class="nf">memory_leak_0014</span> <span class="p">()</span>
371 <span class="p">{</span>
372     <span class="kt">float</span> <span class="o">*</span> <span class="n">fptr</span><span class="p">;</span>
373     <span class="kt">float</span> <span class="o">**</span><span class="n">fp1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fptr</span><span class="p">;</span>
374     <span class="kt">float</span> <span class="o">**</span><span class="n">fp2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fptr</span><span class="p">;</span>
375     <span class="n">fptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &fptr is never used.</span>
376     <span class="p">{</span>
377         <span class="kt">float</span> <span class="o">*</span> <span class="n">fptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">fp1</span><span class="p">;</span>
<span class="result">    > scan-build: (Dead store deadcode.DeadStores) Value stored to 'fptr' during its initialization is never read</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &fptr is never used.</span>
378         <span class="n">fptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
379         <span class="k">if</span><span class="p">(</span><span class="n">fptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
380         <span class="p">{</span>
381            <span class="o">*</span><span class="p">(</span><span class="n">fptr</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mf">50.5</span><span class="p">;</span>
382            <span class="o">*</span><span class="n">fp1</span> <span class="o">=</span> <span class="n">fptr</span><span class="p">;</span>
383         <span class="p">}</span>
384     <span class="p">}</span>
385     <span class="p">{</span>
386         <span class="kt">float</span> <span class="o">*</span> <span class="n">fptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">fp2</span><span class="p">;</span>
387         <span class="n">free</span><span class="p">(</span><span class="n">fptr</span><span class="p">);</span>
388     <span class="p">}</span>
389 <span class="p">}</span>
390 
391 <span class="cm">/*</span>
392 <span class="cm"> * Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
393 <span class="cm"> *  Memory allocated and returned from one function and Memory used in another function</span>
394 <span class="cm"> */</span>
395 <span class="kt">char</span> <span class="o">*</span> <span class="nf">memory_leak_0015_func_001</span> <span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
396 <span class="p">{</span>
397 	<span class="kt">char</span> <span class="o">*</span><span class="n">stringPtr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
398 	<span class="k">return</span> <span class="n">stringPtr</span><span class="p">;</span>
399 <span class="p">}</span>
400 
401 <span class="kt">void</span> <span class="nf">memory_leak_0015</span> <span class="p">()</span>
402 <span class="p">{</span>
403 	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
404 	<span class="kt">char</span> <span class="o">*</span><span class="n">str1</span> <span class="o">=</span> <span class="n">memory_leak_0015_func_001</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
<span class="result">    > flawfinder: ([1] (buffer) strlen) Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).</span>
405 	<span class="k">if</span><span class="p">(</span><span class="n">str1</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
406 	<span class="p">{</span>
407 	   <span class="n">strcpy</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span><span class="n">str</span><span class="p">);</span>
<span class="result">    > flawfinder: ([4] (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused).</span>
408 	   <span class="n">free</span><span class="p">(</span><span class="n">str1</span><span class="p">);</span>
409 	<span class="p">}</span>
410 <span class="p">}</span>
411 
412 <span class="cm">/*</span>
413 <span class="cm">* Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
414 <span class="cm"> *  Memory allocated in a function and Memory used in another function</span>
415 <span class="cm"> */</span>
416 <span class="cp"># define INDEX &#39;a&#39;</span>
417 <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span><span class="n">INDEX</span><span class="p">;</span>
418 <span class="kt">char</span> <span class="o">*</span> <span class="n">memory_leak_0016_gbl_ptr</span><span class="p">;</span>
419 <span class="kt">void</span> <span class="nf">memory_leak_0016_func_001</span> <span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
420 <span class="p">{</span>
421 	<span class="n">memory_leak_0016_gbl_ptr</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
422 	<span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">INDEX</span><span class="p">)</span>
423 		<span class="n">memory_leak_0016_gbl_ptr</span><span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
424 <span class="p">}</span>
425 
426 <span class="kt">void</span> <span class="nf">memory_leak_0016</span> <span class="p">()</span>
427 <span class="p">{</span>
428 	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
429 	<span class="n">memory_leak_0016_func_001</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
<span class="result">    > flawfinder: ([1] (buffer) strlen) Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).</span>
430 	<span class="n">strcpy</span><span class="p">(</span><span class="n">memory_leak_0016_gbl_ptr</span><span class="p">,</span><span class="n">str</span><span class="p">);</span>
<span class="result">    > flawfinder: ([4] (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused).</span>
<span class="result">    > scan-build: (Logic error unix.cstring.NullArg) Null pointer argument in call to string copy function</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `memory_leak_0016_gbl_ptr` last assigned on line 429 could be null and is dereferenced by call to `strcpy()` at line 430, column 2.</span>
431 	<span class="n">free</span><span class="p">(</span><span class="n">memory_leak_0016_gbl_ptr</span><span class="p">);</span>
432 	<span class="n">memory_leak_0016_gbl_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
433 <span class="p">}</span>
434 
435 <span class="cm">/*</span>
436 <span class="cm">* Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
437 <span class="cm">* Complexity: When using a double pointer to long , memory allocated in another function inside goto label and if condition</span>
438 <span class="cm">*/</span>
439 <span class="kt">long</span> <span class="o">**</span> <span class="n">memory_leak_0017_gbl_doubleptr</span><span class="p">;</span>
440 <span class="kt">int</span> <span class="nf">memory_leak_0017_func_001</span><span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
441 <span class="p">{</span>
442    <span class="kt">int</span> <span class="n">ret</span> <span class="p">;</span>
443    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
444 	   <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
445    <span class="k">else</span>
446 	   <span class="n">ret</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
447    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
448 <span class="p">}</span>
449 <span class="kt">void</span> <span class="nf">memory_leak_0017_func_002</span><span class="p">()</span>
450 <span class="p">{</span>
451 	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
452 	<span class="n">memory_leak_0017_gbl_doubleptr</span><span class="o">=</span><span class="p">(</span><span class="kt">long</span><span class="o">**</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
453 
454 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
455 	<span class="p">{</span>
456 		<span class="n">memory_leak_0017_gbl_doubleptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `memory_leak_0017_gbl_doubleptr` last assigned on line 452 could be null and is dereferenced at line 456, column 3.</span>
457 	<span class="p">}</span>
458 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
459 	<span class="p">{</span>
460 		<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
461 		<span class="p">{</span>
462 			<span class="n">memory_leak_0017_gbl_doubleptr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
463 		<span class="p">}</span>
464 	<span class="p">}</span>
465 <span class="p">}</span>
466 
467 <span class="cp">#define ZERO 0</span>
468 <span class="kt">void</span> <span class="nf">memory_leak_0017</span><span class="p">()</span>
469 <span class="p">{</span>
470 	<span class="kt">int</span> <span class="n">flag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
471 	<span class="n">memory_leak_0017_gbl_doubleptr</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
472 <span class="k">goto</span> <span class="n">label</span><span class="p">;</span>
473 
474     <span class="k">if</span><span class="p">(</span><span class="n">memory_leak_0017_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="o">==</span><span class="n">ZERO</span><span class="p">)</span>
475 	<span class="p">{</span>
476 		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
477 		<span class="p">{</span>
478 			<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
479 			<span class="p">{</span>
480 				<span class="n">memory_leak_0017_gbl_doubleptr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
481 			<span class="p">}</span>
482 			<span class="n">free</span> <span class="p">(</span><span class="n">memory_leak_0017_gbl_doubleptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
483 			<span class="n">memory_leak_0017_gbl_doubleptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
484 	   <span class="p">}</span>
485 	    <span class="n">free</span><span class="p">(</span><span class="n">memory_leak_0017_gbl_doubleptr</span><span class="p">);</span>
486 	    <span class="n">memory_leak_0017_gbl_doubleptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
487 	<span class="p">}</span>
488 
489 <span class="nl">label</span><span class="p">:</span>
490     	<span class="k">if</span><span class="p">(</span><span class="n">memory_leak_0017_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="o">==</span><span class="n">ZERO</span><span class="p">)</span>
491     	<span class="p">{</span>
492     		<span class="n">memory_leak_0017_func_002</span><span class="p">();</span>
493     	<span class="p">}</span>
494 <span class="p">}</span>
495 
496 <span class="cm">/*</span>
497 <span class="cm">* Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
498 <span class="cm">* Complexity: When using a double pointer to char in an infinite while loop</span>
499 <span class="cm">*/</span>
500 <span class="cm">/*Allocate Memory */</span>
501 <span class="kt">char</span> <span class="o">**</span><span class="n">memory_leak_0018dst</span><span class="p">;</span>
502 <span class="kt">void</span> <span class="nf">memory_leak_0018_func_001</span><span class="p">()</span>
503 <span class="p">{</span>
504 	<span class="n">memory_leak_0018dst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
505 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
506     <span class="p">{</span>
507 		<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
508 		<span class="p">{</span>
509 			<span class="n">memory_leak_0018dst</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">));</span>
510 		    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
511 		    <span class="p">{</span>
512 		    	<span class="n">memory_leak_0018dst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">15</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span> <span class="cm">/*Tool should not detect  this line as error*/</span> <span class="cm">/*No ERROR:Memory Leakage */</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `memory_leak_0018dst` last assigned on line 509 could be null and is dereferenced at line 512, column 8.</span>
513 		    <span class="p">}</span>
514 		    <span class="k">break</span><span class="p">;</span>
515 		<span class="p">}</span>
516     <span class="p">}</span>
517 <span class="p">}</span>
518 
519 <span class="kt">void</span> <span class="nf">memory_leak_0018</span> <span class="p">()</span>
520 <span class="p">{</span>
521 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
522     <span class="n">memory_leak_0018_func_001</span><span class="p">();</span>
523     <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
524     <span class="p">{</span>
525     	<span class="n">strcpy</span> <span class="p">(</span><span class="n">memory_leak_0018dst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="s">&quot;STRING&quot;</span><span class="p">);</span>
<span class="result">    > flawfinder: ([2] (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused). Risk is low because the source is a constant string.</span>
526     <span class="p">}</span>
527 	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
528 	<span class="p">{</span>
529 		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
530 	    <span class="p">{</span>
531 			<span class="n">free</span><span class="p">(</span><span class="n">memory_leak_0018dst</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
532 			<span class="n">memory_leak_0018dst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
533 	    <span class="p">}</span>
534 	    <span class="n">free</span><span class="p">(</span><span class="n">memory_leak_0018dst</span><span class="p">);</span>
535 	    <span class="n">memory_leak_0018dst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
536 	    <span class="k">break</span><span class="p">;</span>
537 	<span class="p">}</span>
538 <span class="p">}</span>
539 
540 <span class="cm">/*</span>
541 <span class="cm">* Types of defects: Memory Leakage - Allocate Memory and not freeing it</span>
542 <span class="cm">* Complexity:Memory Leakage main function</span>
543 <span class="cm">*/</span>
544 <span class="k">extern</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">vflag</span><span class="p">;</span>
545 <span class="kt">void</span> <span class="nf">memory_leak_main</span> <span class="p">()</span>
546 <span class="p">{</span>
547 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
548 	<span class="p">{</span>
549 		<span class="n">memory_leak_001</span><span class="p">();</span>
550 	<span class="p">}</span>
551 
552 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
553 	<span class="p">{</span>
554 		<span class="n">memory_leak_002</span><span class="p">();</span>
555 	<span class="p">}</span>
556 
557 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
558 	<span class="p">{</span>
559 		<span class="n">memory_leak_003</span><span class="p">();</span>
560 	<span class="p">}</span>
561 
562 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
563 	<span class="p">{</span>
564 		<span class="n">memory_leak_004</span><span class="p">();</span>
565 	<span class="p">}</span>
566 
567 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">5</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
568 	<span class="p">{</span>
569 		<span class="n">memory_leak_005</span><span class="p">();</span>
570 	<span class="p">}</span>
571 
572 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
573 	<span class="p">{</span>
574 		<span class="n">memory_leak_006</span><span class="p">();</span>
575 	<span class="p">}</span>
576 
577 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">7</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
578 	<span class="p">{</span>
579 		<span class="n">memory_leak_007</span><span class="p">();</span>
580 	<span class="p">}</span>
581 
582 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
583 	<span class="p">{</span>
584 		<span class="n">memory_leak_008</span><span class="p">();</span>
585 	<span class="p">}</span>
586 
587 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">9</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
588 	<span class="p">{</span>
589 		<span class="n">memory_leak_009</span><span class="p">();</span>
590 	<span class="p">}</span>
591 
592 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
593 	<span class="p">{</span>
594 		<span class="n">memory_leak_0010</span><span class="p">();</span>
595 	<span class="p">}</span>
596 
597 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">11</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
598 	<span class="p">{</span>
599 		<span class="n">memory_leak_0011</span><span class="p">();</span>
600 	<span class="p">}</span>
601 
602 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">12</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
603 	<span class="p">{</span>
604 		<span class="n">memory_leak_0012</span><span class="p">();</span>
605 	<span class="p">}</span>
606 
607 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">13</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
608 	<span class="p">{</span>
609 		<span class="n">memory_leak_0013</span><span class="p">();</span>
610 	<span class="p">}</span>
611 
612 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">14</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
613 	<span class="p">{</span>
614 		<span class="n">memory_leak_0014</span><span class="p">();</span>
615 	<span class="p">}</span>
616 
617 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">15</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
618 	<span class="p">{</span>
619 		<span class="n">memory_leak_0015</span><span class="p">();</span>
620 	<span class="p">}</span>
621 
622 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">16</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
623 	<span class="p">{</span>
624 		<span class="n">memory_leak_0016</span><span class="p">();</span>
625 	<span class="p">}</span>
626 
627 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">17</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
628 	<span class="p">{</span>
629 		<span class="n">memory_leak_0017</span><span class="p">();</span>
630 	<span class="p">}</span>
631 
632 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">18</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
633 	<span class="p">{</span>
634 		<span class="n">memory_leak_0018</span><span class="p">();</span>
635 	<span class="p">}</span>
636 
637 <span class="p">}</span>
638 
</pre></div>
</body>
</html>

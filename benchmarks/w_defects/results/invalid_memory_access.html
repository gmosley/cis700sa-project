<!DOCTYPE html>
<html>
<head>
<style>
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0000FF } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
.result { color: #F03434 }
</style>
</head>
<body>
<div class="highlight"><pre>
  1 <span class="cm">/********Software Analysis - FY2013*************/</span>
  2 <span class="cm">/*</span>
  3 <span class="cm">* File Name: invalid_memory_access.c</span>
  4 <span class="cm">* Defect Classification</span>
  5 <span class="cm">* ---------------------</span>
  6 <span class="cm">* Defect Type: Resource management defects</span>
  7 <span class="cm">* Defect Sub-type: Invalid memory access to already freed area</span>
  8 <span class="cm">*</span>
  9 <span class="cm">*/</span>
 10 
 11 <span class="cm">/*</span>
 12 <span class="cm"> * invalid_memory_access.c</span>
 13 <span class="cm"> *</span>
 14 <span class="cm"> *  Created on: Sep 20, 2013</span>
 15 <span class="cm"> *      Author: hemalatha</span>
 16 <span class="cm"> */</span>
 17 
 18 <span class="cp">#include</span> <span class="cpf">&quot;HeaderFile.h&quot;</span><span class="cp"></span>
 19 
 20 <span class="kt">char</span> <span class="o">**</span> <span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">;</span>
 21 <span class="kt">char</span> <span class="o">*</span><span class="n">invalid_memory_access_017_doubleptr_gbl</span><span class="p">;</span>
 22 
 23 <span class="k">static</span> <span class="kt">int</span> <span class="n">staticflag1</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
 24 <span class="cm">/*</span>
 25 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
 26 <span class="cm">* Complexity : Memory is allocated and accessed after free -  when using pointer to int and conditional operator</span>
 27 <span class="cm">*/</span>
 28 <span class="kt">void</span> <span class="nf">invalid_memory_access_001</span> <span class="p">()</span>
 29 <span class="p">{</span>
 30 	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">a</span><span class="p">;</span>
 31 	<span class="kt">int</span> <span class="n">flag</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
 32 
 33     <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span><span class="o">?</span> <span class="p">(</span><span class="n">ptr</span><span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span> <span class="o">:</span> <span class="p">(</span> <span class="n">a</span><span class="o">=</span> <span class="mi">5</span><span class="p">);</span>
 34 
 35     <span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
 36     <span class="p">{</span>
 37     <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span><span class="o">?</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">100</span><span class="p">);</span>
 38 
 39     <span class="k">if</span><span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
 40     <span class="p">{</span>
 41     	<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
 42     <span class="p">}</span>
 43      <span class="p">}</span>
 44     <span class="k">if</span><span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
 45     	<span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > cppcheck: (error deallocuse) Dereferencing 'ptr' after it is deallocated / released</span>
<span class="result">    > scan-build: (Dead store deadcode.DeadStores) Value stored to 'a' is never read</span>
<span class="result">    > scan-build: (Logic error core.NullDereference) Dereference of null pointer</span>
<span class="result">    > scan-build: (Memory error unix.Malloc) Use of memory after it is freed</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &a is never used.</span>
<span class="result">    > infer: (HIGH Use After Free) pointer `` was freed by call to `free()` at line 41, column 6 and is dereferenced or freed at line 45, column 10.</span>
 46 
 47 <span class="p">}</span>
 48 
 49 <span class="cm">/*</span>
 50 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
 51 <span class="cm">*  Complexity : Memory is allocated and accessed after free -</span>
 52 <span class="cm">*  when using pointer to double,conditional statement if ~else using static variable of function scope</span>
 53 <span class="cm">*/</span>
 54 
 55 <span class="kt">void</span> <span class="nf">invalid_memory_access_002</span> <span class="p">()</span>
 56 <span class="p">{</span>
 57 	<span class="kt">double</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">dptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">;</span>
 58 	<span class="k">static</span> <span class="kt">int</span> <span class="n">staticflag</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span>
 59     <span class="k">if</span> <span class="p">(</span><span class="n">staticflag</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
 60     	  	<span class="p">(</span><span class="n">ptr</span><span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)));</span>
 61     <span class="k">else</span>
 62     	  	<span class="p">(</span><span class="n">dptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)));</span>
 63 
 64     <span class="k">if</span>  <span class="p">(</span><span class="n">staticflag</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
 65     		<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">10.5</span><span class="p">);</span>
 66     <span class="k">else</span>
 67     	    <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">dptr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">5.5</span><span class="p">)</span> <span class="p">;</span>
 68 
 69     <span class="k">if</span><span class="p">(</span><span class="n">staticflag</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
 70 
 71     <span class="p">{</span>
 72     	<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
 73     <span class="p">}</span>
 74     <span class="k">else</span>
 75     <span class="p">{</span>
 76     	<span class="n">free</span><span class="p">(</span><span class="n">dptr</span><span class="p">);</span>
 77     <span class="p">}</span>
 78 
 79     <span class="k">if</span><span class="p">(</span><span class="n">staticflag</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
 80     <span class="p">{</span>
 81 	    <span class="p">;</span>
 82 	<span class="p">}</span>
 83     <span class="k">else</span>
 84     	<span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">dptr</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > scan-build: (Memory error unix.Malloc) Use of memory after it is freed</span>
<span class="result">    > infer: (HIGH Use After Free) pointer `` was freed by call to `free()` at line 76, column 6 and is dereferenced or freed at line 84, column 10.</span>
 85 	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf&quot;</span><span class="p">,</span><span class="n">a</span><span class="p">);</span>
<span class="result">    > cppcheck: (error uninitvar) Uninitialized variable: a</span>
 86 <span class="p">}</span>
<span class="result">    > cppcheck: (error memleak) Memory leak: dptr</span>
 87 
 88 <span class="cm">/*</span>
 89 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
 90 <span class="cm">* Complexity: Memory is allocated and accessed after free -</span>
 91 <span class="cm">* When using a pointer to char in an infinite while loop and Strcpy</span>
 92 <span class="cm">*/</span>
 93 <span class="kt">void</span> <span class="nf">invalid_memory_access_003</span> <span class="p">()</span>
 94 <span class="p">{</span>
 95 	<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
 96 	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="o">*</span><span class="n">c</span><span class="p">;</span>
 97 	<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
 98 	<span class="p">{</span>
 99 		<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="mi">25</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
100 		<span class="k">if</span><span class="p">(</span><span class="n">buf</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
101 		<span class="p">{</span>
102 		<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="s">&quot;This is String&quot;</span><span class="p">);</span>
<span class="result">    > flawfinder: ([2]  (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused). Risk is low because the source is a constant string.</span>
103 	    <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
104 		<span class="p">}</span>
105 	    <span class="n">c</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span> <span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
106 	    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
107 	    <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">10</span><span class="p">)</span>
108 	    	<span class="k">break</span><span class="p">;</span>
109 	<span class="p">}</span>
110         <span class="n">psink</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
111 <span class="p">}</span>
112 
113 <span class="cm">/*</span>
114 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
115 <span class="cm">* Complexity: Memory is allocated and accessed after free -</span>
116 <span class="cm">* When using a pointer to char and initialize memory block with memset and if condition using static variable of file scope</span>
117 <span class="cm">*/</span>
118 <span class="kt">void</span> <span class="nf">invalid_memory_access_004</span> <span class="p">()</span>
119 <span class="p">{</span>
120     <span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
121     <span class="k">if</span><span class="p">(</span><span class="n">staticflag1</span><span class="p">)</span>
122     <span class="p">{</span>
123         <span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
124         <span class="k">if</span><span class="p">(</span><span class="n">buf</span> <span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
125         <span class="p">{</span>
126         	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
127             <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
128             <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
129         <span class="p">}</span>
130     <span class="p">}</span>
131     <span class="k">if</span><span class="p">(</span><span class="n">staticflag1</span><span class="p">)</span>
132     <span class="p">{</span>
133         <span class="n">printf</span><span class="p">(</span><span class="s">&quot;String= %s&quot;</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span> <span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > scan-build: (Memory error unix.Malloc) Use of memory after it is freed</span>
134     <span class="p">}</span>
135 <span class="p">}</span>
136 
137 <span class="cm">/*</span>
138 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
139 <span class="cm">* Complexity: When using a pointer to int in a recursive function</span>
140 <span class="cm">*/</span>
141 <span class="kt">int</span> <span class="nf">invalid_memory_access_005</span> <span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
142 <span class="p">{</span>
143 	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">;</span>
144 
145 	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
146 	<span class="p">{</span>
147     	<span class="n">count</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > cppcheck: (error uninitvar) Uninitialized variable: ptr</span>
<span class="result">    > scan-build: (Dead store deadcode.DeadStores) Value stored to 'count' is never read</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &count is never used.</span>
148 		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
149 	<span class="p">}</span>
150     <span class="k">else</span>
151     <span class="p">{</span>
152     	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">calloc</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
153     	<span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
154     	<span class="p">{</span>
155     		<span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">count</span><span class="p">;</span>
156     	    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
157     	<span class="p">}</span>
158     	<span class="k">return</span> <span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="n">invalid_memory_access_005</span><span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
159     <span class="p">}</span>
160 <span class="p">}</span>
161 
162 <span class="cm">/*</span>
163 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
164 <span class="cm">* Complexity: When using double pointers to the type float</span>
165 <span class="cm">*/</span>
166 <span class="kt">void</span> <span class="nf">invalid_memory_access_006</span> <span class="p">()</span>
167 <span class="p">{</span>
168 	<span class="kt">float</span> <span class="o">*</span><span class="n">buf1</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
169 	<span class="kt">float</span> <span class="o">*</span><span class="n">buf2</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
170 	<span class="kt">float</span> <span class="o">*</span><span class="n">buf3</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
171 	<span class="kt">float</span> <span class="o">*</span><span class="n">buf4</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
172 	<span class="kt">float</span> <span class="o">*</span><span class="n">buf5</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
173 	<span class="kt">float</span> <span class="o">**</span><span class="n">pbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">buf1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf5</span><span class="p">};</span>
174 	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
175 	<span class="k">if</span><span class="p">(</span><span class="n">buf2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
176 	<span class="p">{</span>
177 	<span class="n">buf2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
178 	<span class="p">}</span>
179 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
180 	<span class="p">{</span>
181 		<span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">pbuf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="mf">5.0</span><span class="p">;</span>
<span class="result">    > scan-build: (Logic error core.NullDereference) Dereference of null pointer</span>
182 	<span class="p">}</span>
183 	<span class="n">free</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span>
184 	<span class="n">free</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span>
185 	<span class="n">free</span><span class="p">(</span><span class="n">buf3</span><span class="p">);</span>
186 	<span class="n">free</span><span class="p">(</span><span class="n">buf4</span><span class="p">);</span>
187 	<span class="n">free</span><span class="p">(</span><span class="n">buf5</span><span class="p">);</span>
188 	<span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">pbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span><span class="n">buf2</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > cppcheck: (error deallocuse) Dereferencing 'buf2' after it is deallocated / released</span>
189 <span class="p">}</span>
190 
191 <span class="cm">/*</span>
192 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
193 <span class="cm">* Complexity: When using double pointers to the type char 2D array of size [5][15] ,strcpy</span>
194 <span class="cm">*/</span>
195 <span class="kt">void</span> <span class="nf">invalid_memory_access_007</span> <span class="p">()</span>
196 <span class="p">{</span>
197 	<span class="kt">char</span> <span class="o">**</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">));</span>
198 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
199 
200 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
201 		<span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">15</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `ptr` last assigned on line 197 could be null and is dereferenced at line 201, column 3.</span>
202 
203 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
204 	<span class="p">{</span>
205 		<span class="n">strcpy</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="n">i</span><span class="p">),</span><span class="s">&quot;String&quot;</span><span class="p">);</span>
<span class="result">    > flawfinder: ([2]  (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused). Risk is low because the source is a constant string.</span>
206 	    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
207 	    <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
208 	<span class="p">}</span>
209 	<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
210 	<span class="n">strcpy</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="s">&quot;String&quot;</span><span class="p">);</span> <span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > flawfinder: ([2]  (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused). Risk is low because the source is a constant string.</span>
211 <span class="p">}</span>
212 
213 <span class="cm">/*</span>
214 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
215 <span class="cm">* Complexity: When using 1 single char pointer  memcpy function</span>
216 <span class="cm">*/</span>
217 <span class="kt">void</span> <span class="nf">invalid_memory_access_008</span> <span class="p">()</span>
218 <span class="p">{</span>
219 	<span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
220 	<span class="kt">char</span><span class="o">*</span> <span class="n">buf1</span><span class="o">=</span> <span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
221 	<span class="k">if</span><span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
222 	<span class="p">{</span>
223 	<span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
224 	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">buf1</span><span class="p">,</span><span class="mi">11</span><span class="p">);</span> <span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > flawfinder: ([2]  (buffer) memcpy) Does not check for buffer overflows when copying to destination (CWE-120).  Make sure destination can always hold the source data.</span>
<span class="result">    > cppcheck: (error deallocuse) Dereferencing 'buf' after it is deallocated / released</span>
<span class="result">    > scan-build: (Memory error unix.Malloc) Use of memory after it is freed</span>
<span class="result">    > infer: (HIGH Use After Free) pointer `buf` last assigned on line 219 was freed by call to `free()` at line 223, column 2 and is dereferenced or freed at line 224, column 2.</span>
225 	<span class="p">}</span>
226 <span class="p">}</span>
227 
228 <span class="cm">/*</span>
229 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
230 <span class="cm">* Complexity: When using a Union with structure members - Aliasing</span>
231 <span class="cm">*/</span>
232 <span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
233 	<span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
234 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
235 <span class="p">}</span> <span class="n">invalid_memory_access_009_s_001</span><span class="p">;</span>
236 
237 <span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
238 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
239 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
240 <span class="p">}</span> <span class="n">invalid_memory_access_009_s_002</span><span class="p">;</span>
241 
242 <span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
243 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
244 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
245 <span class="p">}</span> <span class="n">invalid_memory_access_009_s_003</span><span class="p">;</span>
246 
247 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
248 	<span class="n">invalid_memory_access_009_s_001</span> <span class="o">*</span><span class="n">s1</span><span class="p">;</span>
249 	<span class="n">invalid_memory_access_009_s_002</span> <span class="n">s2</span><span class="p">;</span>
250 	<span class="n">invalid_memory_access_009_s_003</span> <span class="n">s3</span><span class="p">;</span>
251 <span class="p">}</span> <span class="n">invalid_memory_access_009_uni_001</span><span class="p">;</span>
252 
253 <span class="kt">void</span> <span class="nf">invalid_memory_access_009</span> <span class="p">()</span>
254 <span class="p">{</span>
255 	<span class="n">invalid_memory_access_009_uni_001</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">invalid_memory_access_009_uni_001</span> <span class="o">*</span> <span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span> <span class="n">invalid_memory_access_009_uni_001</span> <span class="p">));</span>
256 	<span class="n">invalid_memory_access_009_uni_001</span> <span class="o">*</span><span class="n">p</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &p is never used.</span>
257 
258     <span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
259     <span class="p">{</span>
260 	<span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span> <span class="o">=</span> <span class="p">(</span><span class="n">invalid_memory_access_009_s_001</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">invalid_memory_access_009_s_001</span><span class="p">));</span>
261 	<span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
262 	<span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
263 
264 	<span class="n">p</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
265 	<span class="n">p</span><span class="o">-&gt;</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="result">    > scan-build: (Logic error core.NullDereference) Access to field 'a' results in a dereference of a null pointer (loaded from field 's1')</span>
266 
267 	<span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">);</span>
268 	<span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">s1</span><span class="p">);</span>
269 	<span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
270 	<span class="n">p</span><span class="o">-&gt;</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > scan-build: (Memory error unix.Malloc) Use of memory after it is freed</span>
271     <span class="p">}</span>
272 <span class="p">}</span>
273 
274 <span class="cm">/*</span>
275 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
276 <span class="cm">* Complexity Memory allocated in a function and Memory used in another function</span>
277 <span class="cm">*/</span>
278 <span class="kt">void</span> <span class="nf">invalid_memory_access_func_010</span> <span class="p">(</span><span class="kt">int</span> <span class="n">len</span> <span class="p">,</span><span class="kt">int</span> <span class="o">**</span><span class="n">Ptr</span><span class="p">)</span>
279 <span class="p">{</span>
280 	<span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">len</span><span class="p">);</span>
281 	<span class="o">*</span><span class="n">Ptr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
282 <span class="p">}</span>
283 
284 <span class="kt">void</span> <span class="nf">invalid_memory_access_010</span> <span class="p">()</span>
285 <span class="p">{</span>
286 	<span class="kt">int</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
287 	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">,</span><span class="n">i</span><span class="p">;</span>
288 	<span class="n">invalid_memory_access_func_010</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ptr1</span><span class="p">);</span>
289 	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
290 	<span class="p">{</span>
291 		<span class="o">*</span><span class="p">(</span><span class="n">ptr1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
292 	<span class="p">}</span>
293 	<span class="n">free</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>
294 	<span class="o">*</span><span class="p">(</span><span class="n">ptr1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > cppcheck: (error deallocuse) Dereferencing 'ptr1' after it is deallocated / released</span>
<span class="result">    > infer: (HIGH Use After Free) pointer `` was freed by call to `free()` at line 293, column 2 and is dereferenced or freed at line 294, column 2.</span>
295 <span class="p">}</span>
296 
297 <span class="cm">/*</span>
298 <span class="cm">* Types of defects: Invalid memory access</span>
299 <span class="cm">* Complexity: 1-dimensional array</span>
300 <span class="cm">*/</span>
301 <span class="kt">void</span> <span class="nf">invalid_memory_access_011</span> <span class="p">()</span>
302 <span class="p">{</span>
303 	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
304 	<span class="kt">int</span> <span class="n">index</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
305 	<span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
306 	<span class="p">{</span>
307 		<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
308 		<span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
309 		<span class="p">{</span>
310 		   <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">)</span>
311 		   <span class="p">{</span>
312 			   <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
313 	           <span class="n">i</span><span class="o">++</span><span class="p">;</span>
314 	       <span class="p">}</span>
315 	       <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
316 		<span class="p">}</span>
317 	    <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">)</span>
318 	    <span class="k">break</span><span class="p">;</span>
319 	<span class="p">}</span>
320 	 <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
321 <span class="p">}</span>
322 
323 <span class="cm">/*</span>
324 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
325 <span class="cm">* Complexity: When using switch case</span>
326 <span class="cm">*/</span>
327 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
328 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
329 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
330 	<span class="kt">int</span> <span class="n">uninit</span><span class="p">;</span>
331 <span class="p">}</span> <span class="n">invalid_memory_access_012_s_001</span><span class="p">;</span>
332 
333 <span class="kt">int</span> <span class="nf">invalid_memory_access_012_func_001</span> <span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
334 <span class="p">{</span>
335 
336 	<span class="n">invalid_memory_access_012_s_001</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
337 	<span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">invalid_memory_access_012_s_001</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">invalid_memory_access_012_s_001</span><span class="p">));</span>
338 	<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
339 	<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
340 	<span class="p">{</span>
341 		<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
342 		<span class="p">{</span>
343 			<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
344 			<span class="p">{</span>
345 			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
346 			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
347 			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">uninit</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
348 			     <span class="n">i</span><span class="o">=</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
349      			 <span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
350 			<span class="p">}</span>
351 			<span class="k">break</span><span class="p">;</span>
352 		<span class="p">}</span>
353 		<span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
354 		<span class="p">{</span>
355 			<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
356 			<span class="p">{</span>
357 			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
358 			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
359 			     <span class="n">s</span><span class="o">-&gt;</span><span class="n">uninit</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
360 			     <span class="n">i</span><span class="o">=</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
361      			 <span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
362 			<span class="p">}</span>
363 			<span class="k">break</span><span class="p">;</span>
364 		<span class="p">}</span>
365 		<span class="k">default</span><span class="o">:</span>
366 		<span class="p">{</span>
367 			<span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
368 			<span class="k">break</span><span class="p">;</span>
369 		<span class="p">}</span>
370 	<span class="p">}</span>
371 	<span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">);</span><span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > scan-build: (Logic error core.NullDereference) Access to field 'a' results in a dereference of a null pointer (loaded from variable 's')</span>
<span class="result">    > scan-build: (Memory error unix.Malloc) Use of memory after it is freed</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `s` last assigned on line 337 could be null and is dereferenced at line 371, column 12.</span>
<span class="result">    > infer: (HIGH Use After Free) pointer `s` last assigned on line 337 was freed by call to `free()` at line 367, column 4 and is dereferenced or freed at line 371, column 12.</span>
372 <span class="p">}</span>
373 
374 <span class="kt">void</span> <span class="nf">invalid_memory_access_012</span> <span class="p">()</span>
375 <span class="p">{</span>
376 	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
377 	<span class="n">ret</span> <span class="o">=</span> <span class="n">invalid_memory_access_012_func_001</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
378 	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="n">ret</span><span class="p">);</span>
379 <span class="p">}</span>
380 
381 <span class="cm">/*</span>
382 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
383 <span class="cm">* Complexity: Double pointer - double	Alias for 1 weight	Address	Constant	Write</span>
384 <span class="cm">*/</span>
385 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
386 	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
387 	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
388 	<span class="kt">int</span> <span class="n">uninit</span><span class="p">;</span>
389 <span class="p">}</span> <span class="n">invalid_memory_access_013_s_001</span><span class="p">;</span>
390 <span class="n">invalid_memory_access_013_s_001</span> <span class="o">*</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="p">;</span>
391 
392 <span class="kt">void</span> <span class="nf">invalid_memory_access_013_func_001</span> <span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
393 <span class="p">{</span>
394 	<span class="k">if</span><span class="p">(</span><span class="n">flag</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
395 	<span class="n">invalid_memory_access_013_s_001_s_gbl</span> <span class="o">=</span> <span class="p">(</span><span class="n">invalid_memory_access_013_s_001</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">invalid_memory_access_013_s_001</span><span class="p">));</span>
396 <span class="p">}</span>
397 
398 <span class="kt">int</span> <span class="nf">invalid_memory_access_013_func_002</span> <span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
399 <span class="p">{</span>
400 	<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &i is never used.</span>
401 	<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
402 	<span class="p">{</span>
403 		<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
404 		<span class="p">{</span>
405 			<span class="k">if</span> <span class="p">(</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
406 			<span class="p">{</span>
407 				<span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
408 				<span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
409 				<span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">uninit</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
410 				<span class="n">i</span><span class="o">=</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
<span class="result">    > scan-build: (Dead store deadcode.DeadStores) Value stored to 'i' is never read</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &i is never used.</span>
411 				<span class="n">free</span><span class="p">(</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="p">);</span>
412 			<span class="p">}</span>
413 			<span class="k">break</span><span class="p">;</span>
414 		<span class="p">}</span>
415 		<span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
416 		<span class="p">{</span>
417 			<span class="k">if</span> <span class="p">(</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
418 			<span class="p">{</span>
419 				<span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
420 				<span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
421 				<span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">uninit</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
422 				<span class="n">i</span><span class="o">=</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
<span class="result">    > scan-build: (Dead store deadcode.DeadStores) Value stored to 'i' is never read</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &i is never used.</span>
423 				<span class="n">free</span><span class="p">(</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="p">);</span>
424 			<span class="p">}</span>
425 			<span class="k">break</span><span class="p">;</span>
426 		<span class="p">}</span>
427 		<span class="k">default</span><span class="o">:</span>
428 		<span class="p">{</span>
429 			<span class="k">break</span><span class="p">;</span>
430 		<span class="p">}</span>
431 	<span class="p">}</span>
432 	<span class="k">return</span> <span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span><span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > scan-build: (Logic error core.NullDereference) Access to field 'a' results in a dereference of a null pointer (loaded from variable 'invalid_memory_access_013_s_001_s_gbl')</span>
<span class="result">    > scan-build: (Memory error unix.Malloc) Use of memory after it is freed</span>
<span class="result">    > infer: (HIGH Use After Free) pointer `invalid_memory_access_013_s_001_s_gbl` last accessed on line 405 was freed by call to `free()` at line 411, column 5 and is dereferenced or freed at line 432, column 9.</span>
433 <span class="cm">/*	return i;*/</span>
434 <span class="p">}</span>
435 
436 <span class="kt">void</span> <span class="nf">invalid_memory_access_013_func_003</span> <span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
437 <span class="p">{</span>
438 	<span class="n">invalid_memory_access_013_s_001</span> <span class="n">s</span><span class="p">;</span>
439 	<span class="k">if</span><span class="p">(</span><span class="n">flag</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
440 	<span class="p">{</span>
441 		<span class="k">if</span> <span class="p">(</span><span class="n">invalid_memory_access_013_s_001_s_gbl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
442 		<span class="p">{</span>
443 			<span class="n">s</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
444 			<span class="n">s</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span>
445 			<span class="n">s</span><span class="p">.</span><span class="n">uninit</span> <span class="o">=</span> <span class="n">invalid_memory_access_013_s_001_s_gbl</span><span class="o">-&gt;</span><span class="n">uninit</span><span class="p">;</span>
446 		<span class="p">}</span>
447 	<span class="p">}</span>
448 <span class="p">}</span>
449 
450 <span class="kt">void</span> <span class="nf">invalid_memory_access_013</span> <span class="p">()</span>
451 <span class="p">{</span>
452 	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
453 	<span class="n">invalid_memory_access_013_func_001</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
454 	<span class="n">ret</span> <span class="o">=</span> <span class="n">invalid_memory_access_013_func_002</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `invalid_memory_access_013_s_001_s_gbl` last assigned on line 453 could be null and is dereferenced by call to `invalid_memory_access_013_func_002()` at line 454, column 8.</span>
455 	<span class="n">invalid_memory_access_013_func_003</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
456 
457 	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="n">ret</span><span class="p">);</span>
458 <span class="p">}</span>
459 
460 <span class="cm">/*</span>
461 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
462 <span class="cm">* Complexity: When using a pointer to int and  goto</span>
463 <span class="cm">*/</span>
464 <span class="kt">int</span> <span class="nf">invalid_memory_access_014</span> <span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
465 <span class="p">{</span>
466 	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">;</span>
467 	<span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
468 	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span><span class="p">);</span>
469 	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
470 	<span class="p">{</span>
471 		<span class="k">goto</span> <span class="n">my_label</span><span class="p">;</span>
472 	<span class="p">}</span>
473 	<span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
474 	<span class="p">{</span>
475    		<span class="k">goto</span> <span class="n">my_label2</span><span class="p">;</span>
476         <span class="n">ret</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
477 
478 	<span class="p">}</span>
479 <span class="nl">my_label</span><span class="p">:</span>
480 	    <span class="p">{</span>
481             <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
482             <span class="p">{</span>
483             	<span class="k">if</span><span class="p">(</span><span class="n">ptr</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
484             		<span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
485             <span class="p">}</span>
486 
487 	    <span class="p">}</span>
488 <span class="nl">my_label2</span><span class="p">:</span>
489     <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
490 	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
491 <span class="p">}</span>
492 
493 <span class="cm">/*</span>
494 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
495 <span class="cm">* Complexity: Use a block of memory returned from a function after it has been freed</span>
496 <span class="cm">*/</span>
497 
498 <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">invalid_memory_access_015_func_001</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str1</span><span class="p">)</span>
499 <span class="p">{</span>
500     <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &i is never used.</span>
501     <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
502     <span class="kt">char</span> <span class="o">*</span> <span class="n">str_rev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &str_rev is never used.</span>
503     <span class="k">if</span> <span class="p">(</span><span class="n">str1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
504     <span class="p">{</span>
505         <span class="n">i</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str1</span><span class="p">);</span>
<span class="result">    > flawfinder: ([1]  (buffer) strlen) Does not handle strings that are not \0-terminated; if given one it may perform an over-read (it could cause a crash if unprotected) (CWE-126).</span>
506         <span class="n">str_rev</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
507         <span class="k">if</span> <span class="p">(</span><span class="n">str_rev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
508         <span class="p">{</span>
509         	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
510             <span class="p">{</span>
511                 <span class="n">str_rev</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
512             <span class="p">}</span>
513             <span class="n">str_rev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
514         <span class="p">}</span>
515         <span class="n">free</span><span class="p">(</span><span class="n">str_rev</span><span class="p">)</span> <span class="p">;</span>
516         <span class="k">return</span> <span class="n">str_rev</span><span class="p">;</span><span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > cppcheck: (error deallocret) Returning/dereferencing 'str_rev' after it is deallocated / released</span>
<span class="result">    > scan-build: (Memory error unix.Malloc) Use of memory after it is freed</span>
517     <span class="p">}</span>
518     <span class="k">else</span>
519     <span class="p">{</span>
520         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
521     <span class="p">}</span>
522 <span class="p">}</span>
523 <span class="kt">void</span> <span class="nf">invalid_memory_access_015</span> <span class="p">()</span>
524 <span class="p">{</span>
525     <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
526     <span class="kt">char</span> <span class="n">buf</span><span class="p">[][</span><span class="mi">25</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;This is a String&quot;</span><span class="p">,</span>
527     		     <span class="s">&quot;Second String&quot;</span><span class="p">};</span>
528     <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
529     <span class="p">{</span>
530         <span class="p">{</span>
531             <span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">;</span>
532             <span class="n">str</span> <span class="o">=</span> <span class="n">invalid_memory_access_015_func_001</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="result">    > scan-build: (Dead store deadcode.DeadStores) Value stored to 'str' is never read</span>
<span class="result">    > infer: (HIGH Dead Store) The value written to &str is never used.</span>
533         <span class="p">}</span>
534     <span class="p">}</span>
535 <span class="p">}</span>
536 
537 <span class="cm">/*</span>
538 <span class="cm">* Types of defects: Uninitialized pointer</span>
539 <span class="cm">* Complexity: global char double pointer  variable initialized in another function</span>
540 <span class="cm"> */</span>
541 <span class="kt">int</span> <span class="nf">invalid_memory_access_016_func_001</span><span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
542 <span class="p">{</span>
543    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
544    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
545 	   <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
546    <span class="k">else</span>
547 	   <span class="n">ret</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
548    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
549 <span class="p">}</span>
550 
551 <span class="kt">void</span> <span class="nf">invalid_memory_access_016_func_002</span><span class="p">()</span>
552 <span class="p">{</span>
553 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
554 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_016_func_001</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
555 	<span class="p">{</span>
556 		<span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">));</span>
557     	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
558 	    <span class="p">{</span>
559     		<span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `invalid_memory_access_016_doubleptr_gbl` last assigned on line 556 could be null and is dereferenced at line 559, column 7.</span>
560     		   <span class="n">strcpy</span><span class="p">(</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="s">&quot;STRING00&quot;</span><span class="p">);</span>
<span class="result">    > flawfinder: ([2]  (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused). Risk is low because the source is a constant string.</span>
<span class="result">    > infer: (HIGH Null Dereference) pointer `*invalid_memory_access_016_doubleptr_gbl[i]` last assigned on line 559 could be null and is dereferenced by call to `strcpy()` at line 560, column 10.</span>
561 	    <span class="p">}</span>
562 	<span class="p">}</span>
563 <span class="p">}</span>
564 
565 <span class="kt">void</span> <span class="nf">invalid_memory_access_016_func_003</span><span class="p">()</span>
566 <span class="p">{</span>
567 	<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
<span class="result">    > flawfinder: ([2]  (buffer) char) Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).  Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.</span>
568 	<span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > flawfinder: ([4]  (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused).</span>
<span class="result">    > scan-build: (Logic error core.NullDereference) Array access (from variable 'invalid_memory_access_016_doubleptr_gbl') results in a null pointer dereference</span>
569 <span class="p">}</span>
570 
571 <span class="kt">void</span> <span class="nf">invalid_memory_access_016</span><span class="p">()</span>
572 <span class="p">{</span>
573 	<span class="kt">int</span> <span class="n">flag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">;</span>
574 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_016_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
575 	<span class="p">{</span>
576 		<span class="n">invalid_memory_access_016_func_002</span><span class="p">();</span>
577 	<span class="p">}</span>
578 
579 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
580 	<span class="p">{</span>
581 		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
582 		<span class="p">{</span>
583 			<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
584 			<span class="n">free</span> <span class="p">(</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
585 	    <span class="p">}</span>
586 	    <span class="n">free</span><span class="p">(</span><span class="n">invalid_memory_access_016_doubleptr_gbl</span><span class="p">);</span>
587 	<span class="p">}</span>
588 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_016_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
589 	<span class="p">{</span>
590 		<span class="n">invalid_memory_access_016_func_003</span><span class="p">();</span>
591 	<span class="p">}</span>
592 <span class="p">}</span>
593 <span class="cm">/*</span>
594 <span class="cm">* Types of defects: Uninitialized pointer</span>
595 <span class="cm">* Complexity: global char pointer  variable initialized in another function , freed in another function based in while loop</span>
596 <span class="cm"> */</span>
597 <span class="kt">int</span> <span class="nf">invalid_memory_access_017_func_001</span><span class="p">(</span><span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
598 <span class="p">{</span>
599    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
600    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
601 	   <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
602    <span class="k">else</span>
603 	   <span class="n">ret</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
604    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
605 <span class="p">}</span>
606 
607 <span class="kt">void</span> <span class="nf">invalid_memory_access_017_func_002</span><span class="p">()</span>
608 <span class="p">{</span>
609 	<span class="n">invalid_memory_access_017_doubleptr_gbl</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
610 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_017_doubleptr_gbl</span> <span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
611 	<span class="n">strcpy</span><span class="p">(</span><span class="n">invalid_memory_access_017_doubleptr_gbl</span><span class="p">,</span><span class="s">&quot;TEST&quot;</span><span class="p">);</span>
<span class="result">    > flawfinder: ([2]  (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused). Risk is low because the source is a constant string.</span>
612 <span class="p">}</span>
613 
614 <span class="kt">void</span> <span class="nf">invalid_memory_access_017_func_003</span><span class="p">()</span>
615 <span class="p">{</span>
616 	<span class="n">free</span><span class="p">(</span><span class="n">invalid_memory_access_017_doubleptr_gbl</span><span class="p">);</span>
617 <span class="p">}</span>
618 
619 <span class="kt">void</span> <span class="nf">invalid_memory_access_017_func_004</span><span class="p">()</span>
620 <span class="p">{</span>
621 	<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
<span class="result">    > flawfinder: ([2]  (buffer) char) Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119!/CWE-120).  Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.</span>
622 	<span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">invalid_memory_access_017_doubleptr_gbl</span><span class="p">);</span><span class="cm">/*Tool should detect this line as error*/</span> <span class="cm">/*ERROR:Invalid memory access to already freed area*/</span>
<span class="result">    > flawfinder: ([4]  (buffer) strcpy) Does not check for buffer overflows when copying to destination [MS-banned] (CWE-120).  Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy easily misused).</span>
<span class="result">    > scan-build: (Memory error unix.Malloc) Use of memory after it is freed</span>
623 <span class="p">}</span>
624 
625 <span class="kt">void</span> <span class="nf">invalid_memory_access_017</span><span class="p">()</span>
626 <span class="p">{</span>
627 	<span class="kt">int</span> <span class="n">flag</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
628 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_017_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
629 	<span class="p">{</span>
630 		<span class="p">;</span>
631 	<span class="p">}</span>
632 	<span class="k">else</span>
633 	<span class="p">{</span>
634 		<span class="n">invalid_memory_access_017_func_002</span><span class="p">();</span>
635 	<span class="p">}</span>
636 
637 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_017_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
638 	<span class="p">{</span>
639 		<span class="p">;</span>
640 	<span class="p">}</span>
641 	<span class="k">else</span>
642 	<span class="p">{</span>
643 		<span class="n">invalid_memory_access_017_func_003</span><span class="p">();</span>
644 	<span class="p">}</span>
645 
646 	<span class="k">if</span><span class="p">(</span><span class="n">invalid_memory_access_017_func_001</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
647 	<span class="p">{</span>
648 		<span class="p">;</span>
649 	<span class="p">}</span>
650 	<span class="k">else</span>
651 	<span class="p">{</span>
652 		<span class="n">invalid_memory_access_017_func_004</span><span class="p">();</span>
<span class="result">    > infer: (HIGH Use After Free) pointer `invalid_memory_access_017_doubleptr_gbl` was freed by call to `invalid_memory_access_017_func_003()` at line 643, column 3 and is dereferenced or freed at line 652, column 3.</span>
653 	<span class="p">}</span>
654 <span class="p">}</span>
655 
656 <span class="cm">/*</span>
657 <span class="cm">* Types of defects: Invalid memory access to already freed area(Dangling pointers)</span>
658 <span class="cm">* Complexity:Invalid memory access main function</span>
659 <span class="cm">*/</span>
660 <span class="k">extern</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">vflag</span><span class="p">;</span>
661 <span class="kt">void</span> <span class="nf">invalid_memory_access_main</span> <span class="p">()</span>
662 <span class="p">{</span>
663 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
664 	<span class="p">{</span>
665 		<span class="n">invalid_memory_access_001</span><span class="p">();</span>
666 	<span class="p">}</span>
667 
668 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
669 	<span class="p">{</span>
670 		<span class="n">invalid_memory_access_002</span><span class="p">();</span>
671 	<span class="p">}</span>
672 
673 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
674 	<span class="p">{</span>
675 		<span class="n">invalid_memory_access_003</span><span class="p">();</span>
676 	<span class="p">}</span>
677 
678 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
679 	<span class="p">{</span>
680 		<span class="n">invalid_memory_access_004</span><span class="p">();</span>
681 	<span class="p">}</span>
682 
683 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">5</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
684 	<span class="p">{</span>
685 		<span class="n">invalid_memory_access_005</span> <span class="p">(</span><span class="mi">5</span><span class="p">);</span>
686 	<span class="p">}</span>
687 
688 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
689 	<span class="p">{</span>
690 		<span class="n">invalid_memory_access_006</span><span class="p">();</span>
691 	<span class="p">}</span>
692 
693 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">7</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
694 	<span class="p">{</span>
695 		<span class="n">invalid_memory_access_007</span><span class="p">();</span>
696 	<span class="p">}</span>
697 
698 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
699 	<span class="p">{</span>
700 		<span class="n">invalid_memory_access_008</span><span class="p">();</span>
701 	<span class="p">}</span>
702 
703 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">9</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
704 	<span class="p">{</span>
705 		<span class="n">invalid_memory_access_009</span><span class="p">();</span>
706 	<span class="p">}</span>
707 
708 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
709 	<span class="p">{</span>
710 		<span class="n">invalid_memory_access_010</span><span class="p">();</span>
711 	<span class="p">}</span>
712 
713 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">11</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
714 	<span class="p">{</span>
715 		<span class="n">invalid_memory_access_011</span><span class="p">();</span>
716 	<span class="p">}</span>
717 
718 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">12</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
719 	<span class="p">{</span>
720 		<span class="n">invalid_memory_access_012</span><span class="p">();</span>
721 	<span class="p">}</span>
722 
723 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">13</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
724 	<span class="p">{</span>
725 		<span class="n">invalid_memory_access_013</span><span class="p">();</span>
726 	<span class="p">}</span>
727 
728 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">14</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
729 	<span class="p">{</span>
730 		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
731 		<span class="n">i</span> <span class="o">=</span> <span class="n">invalid_memory_access_014</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
732                 <span class="n">sink</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
733 	<span class="p">}</span>
734 
735 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">15</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
736 	<span class="p">{</span>
737 		<span class="n">invalid_memory_access_015</span><span class="p">();</span>
738 	<span class="p">}</span>
739 
740 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">16</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
741 	<span class="p">{</span>
742 		<span class="n">invalid_memory_access_016</span><span class="p">();</span>
743 	<span class="p">}</span>
744 
745 	<span class="k">if</span> <span class="p">(</span><span class="n">vflag</span> <span class="o">==</span> <span class="mi">17</span> <span class="o">||</span> <span class="n">vflag</span> <span class="o">==</span><span class="mi">888</span><span class="p">)</span>
746 	<span class="p">{</span>
747 		<span class="n">invalid_memory_access_017</span><span class="p">();</span>
748 	<span class="p">}</span>
749 <span class="p">}</span>
750 
</pre></div>
</body>
</html>
